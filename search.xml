<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一章 概述</title>
    <url>/2020/08/29/fg89b3/</url>
    <content><![CDATA[<h2 id="网络-network"><a href="#网络-network" class="headerlink" title="网络 network"></a>网络 network</h2><p>网络： an intricately connected system of  objects, devices, or people</p>
<p>网络分类：</p>
<p>传播技术分类：broadcast networks，point-to-point networks</p>
<p>覆盖范围分类：LAN，WAN</p>
<h3 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h3><p>LAN 特点：Operate locally (cover small areas)</p>
<p>Multi-user access</p>
<p>High speeds expected (up to 10Gbps)</p>
<p>Error rate is easily controlled</p>
<p>device：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372396804-2fa52971-1e43-444c-886b-b337abacfd3e.png#alt=3E395597-7084-4327-8600-51B3F0A1F279" alt=""></p>
<p>service：以太网</p>
<h3 id="WAN"><a href="#WAN" class="headerlink" title="WAN"></a>WAN</h3><p>WAN 特点：Operate over larger areas</p>
<p>Access over serial links, optical links, etc.</p>
<p>Traditionally, have Lower speeds</p>
<p>Error rate can not be easily controlled</p>
<p>device：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372396367-74b9e02c-8b91-482d-94d7-30aa4365dc64.png#alt=C129B1EF-698E-4520-8AD7-829E02C0B1BC" alt=""></p>
<p>服务：Modem，ISDN，DSL，Frame Relay，ATM，1/E1，T3，STS-1, STS-3, STS-48 (SONET/SDH)</p>
<h3 id="internet"><a href="#internet" class="headerlink" title="internet"></a>internet</h3><p>isp internet service providers</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372396265-52516a7e-565f-45b7-982a-9349e9caf760.png#alt=056345FE-DB73-4109-AC88-E28E1D9B5944" alt=""></p>
<p>数据 data：以 bits 形式发送，不是信息本身，是信息的一种编码格式，<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372393343-85b0b67d-bdab-4c04-8ea9-28716fa522ba.jpeg#alt=-w494" alt=""></p>
<p>数据包 data packets ：为了传输，data 被分为更小的单元被称为：packets, or frames or segments</p>
<p>协议 protocol：不同类型的计算机可以相互交流</p>
<p>source，destination</p>
<h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372395894-493437f1-1445-4fc2-b886-0d465e1be6ad.jpeg#alt=-w592" alt=""></p>
<h2 id="OSI-open-system-interconnection-reference-model"><a href="#OSI-open-system-interconnection-reference-model" class="headerlink" title="OSI(open system interconnection) reference model"></a>OSI(open system interconnection) reference model</h2><p>上层向下层请求服务，下层实施服务</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372396124-b6a6ff73-b96b-4883-a910-ef2543783d32.jpeg#alt=-w688" alt=""></p>
<p><strong>分层模型优点</strong>：减少复杂度，标准化接口，促进模块工程化，确保互动技术，加速更新，简化教学</p>
<p>top3layers 被称为应用层，因为他们处理用户接口，数据格式化和应用访问</p>
<p>后四层被称为数据流层（dataflow）因为他们控制信息通过网络的物理传输</p>
<p>layer1:Signal and Media。规范了可传输的介质和信号，传输的规格，不做控制管理，不对数据进行判断</p>
<p>layer2：, media access control</p>
<p>layer3:Path selection, Routing, Addressing，ip 定位。设备之间连接，可覆盖 lan</p>
<p>layer4:Reliability, Flow control, （1 ～ 3 无严格的数据检验）</p>
<p>layer5:Dialog and Conversations</p>
<p>layer6:Common Format 加密，压缩</p>
<p>layer7:Browser</p>
<h3 id="protocol-on-ISO"><a href="#protocol-on-ISO" class="headerlink" title="protocol on ISO"></a>protocol on ISO</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372394785-356536b3-b2fc-49bf-8b78-d53246c01c1b.png#alt=BCC8E43C-AB19-4F90-949B-03AEA5E4F023" alt=""></p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372396215-68be36cf-7fd5-4cbb-9cfd-8dd337559454.jpeg#alt=-w638" alt=""></p>
<h3 id="同层交流"><a href="#同层交流" class="headerlink" title="同层交流"></a>同层交流</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372395970-fa10b6d4-7c32-4a4e-a4d8-31ff21a798de.png#alt=634C8D15-76D0-4874-AF73-24806940BDAE" alt=""></p>
<h2 id="TCP-IP-model"><a href="#TCP-IP-model" class="headerlink" title="TCP/IP model"></a>TCP/IP model</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372394801-b0434b6b-8588-4969-b2cd-4041ba3b7d19.jpeg#alt=-w281" alt=""></p>
<h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><p>this data is properly packaged for the next layer.</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p>处理 reliability, flow control, and error correction 单元：segments</p>
<h3 id="internet-1"><a href="#internet-1" class="headerlink" title="internet"></a>internet</h3><p>接受并发送源数据包到指定目的</p>
<p>处理 independent of the path and networks ，Best path determination and packet switching</p>
<h3 id="network-access"><a href="#network-access" class="headerlink" title="network access"></a>network access</h3><p>也称为 host-to-network layer</p>
<h3 id="tcp-ip-协议"><a href="#tcp-ip-协议" class="headerlink" title="tcp/ip 协议"></a>tcp/ip 协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372395172-5fbada36-9e14-439f-beb2-4c8ab692ed73.jpeg#alt=-w612" alt=""></p>
<p>FTP - File TransferProtocol</p>
<p>HTTP - HypertextTransfer Protocol</p>
<p>SMTP - Simple Mail Transfer protocol</p>
<p>DNS - Domain Name System</p>
<p>TFTP - Trivial File Transfer Protocol</p>
<h3 id="tcp-ip-和-osi-异同"><a href="#tcp-ip-和-osi-异同" class="headerlink" title="tcp/ip 和 osi 异同"></a>tcp/ip 和 osi 异同</h3><p>同：都采用分层和网络专业技术，都有应用层（虽然包括不同的协议），都有传输层和采用报文交换技术</p>
<p>异：tcp/ip 更为简单，tcp/ip 协议被广泛使用，因此 tcp/ip 更可靠。osi 协议可能仅作为一个参考</p>
<h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>拓扑(topology) Defines the structure of the network</p>
<p>物理拓扑：the actual layout of the wire (media)bus, star, ring, extended star, hierarchical, mesh</p>
<p>逻辑拓扑：defines how the media is accessed by the hosts</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372396490-2eca1d90-57f3-42de-919f-e6c0efd413ed.png#alt=A63CAB2F-5733-4A55-86D0-48C71EACE25D" alt=""></p>
<p>bus：所有设备连接在一条总线上。总线不做控制，广播式传输。</p>
<p>优点：成本低，接入方便，直接通讯。</p>
<p>缺点：一处破损导致整个线路的瘫痪</p>
<p>ring：只能朝一个方向连接</p>
<p>dual ring：</p>
<p>star： 可以互相交流，安全性较好。中心节点有问题，整个网络瘫痪</p>
<p>tree：有层次关系（权限）</p>
<p>mesh：连通性可靠</p>
<p>cellular：用于无限技术</p>
<h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><p>终端设备：工作环境复杂，功能齐全.工作在所有层次。</p>
<h3 id="网卡-NIC"><a href="#网卡-NIC" class="headerlink" title="网卡 NIC"></a>网卡 NIC</h3><p>host 通过 nic 接入网络</p>
<p>第二层设备，带有 mac 地址（固定地址）用来控制数据通信。转化计算机产生的产生的并行信号为穿行信号<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372394837-cbff8057-1df2-47ac-8565-6c10d6983cdb.png#alt=D993497C-5F20-4F21-819F-B02043284F31" alt=""></p>
<p>网络中间设备也含有网卡</p>
<h3 id="中继器-repeater"><a href="#中继器-repeater" class="headerlink" title="中继器 repeater"></a>中继器 repeater</h3><p>两个端口</p>
<p>第一层设备。用于扩展网络长度，清理，放大，再转发信号</p>
<h3 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h3><p>第一层设备。多端口中继器</p>
<p>可能会造成冲突，不允许设备同时使用。（物理上是星形，逻辑上 bus 拓扑）</p>
<h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>两个端口。根据设备的 mac 地址，将网段分为两个分段，并形成 mac table</p>
<p>可以分为不同的冲突域</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>网桥和 hub 的结合。分成更小的冲突域。</p>
<p>物理和逻辑上都是星形。</p>
<p>第二层设备只能基于 mac 地址的划分</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>根据 ip 地址进行划分。</p>
<p>进行不同网段的划分。</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 会话层，表示层，应用层 &amp;amp; dhcp</title>
    <url>/2020/08/29/gci4xx/</url>
    <content><![CDATA[<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>开始，停止，再同步两台主机之间的会话。<br>检查点：分离会话，确保同步。若数据出错，回到之前的主同步点</p>
<p>会话过程：服务的请求和应答</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>屏蔽不同计算机在表示上的差异<br>主要功能： Data formatting 格式，Data compression 压缩，Data encryption 加密<br>EBCDIC 和 ASCII 转换<br>图片文件格式： Graphic Interchange Format（GIF），Joint Photographic Experts Group (JPEG).</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用户的交互界面<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647163201-dd3319cb-3ff1-4b94-815b-c8e91b4ac694.png" alt="71631E4A-8EBF-4809-B739-7087EEE10DB0"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议 HyperText Transfer Protocol<br>超文本：内容更丰富，连接/标志-》URL，浏览器上显示-〉html，转发/传输-》http</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>Uniform Resource Locator,统一资源定位器<br>可以认为是语法标准。对资源进行定位<br>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针<br>格式：</p>
<blockquote>
<p>&lt;URL 的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
</blockquote>
<h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3><p>面向事务的客户服务器协议。<br>无状态/独立的，本身无连接<br>浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为 HTTP daemon，缩写为 HTTPD。 HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户。</p>
<h3 id="http-报文结构"><a href="#http-报文结构" class="headerlink" title="http 报文结构"></a>http 报文结构</h3><p>请求报文<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597647162638-482b16bb-890e-44d2-aa4a-952c17d4ebc4.jpeg" alt="-w683"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647162590-99c4bed7-f10b-4891-90ae-90967248af59.png" alt="86A96B58-715A-460B-ACF5-54822C0FCD54"></p>
<p>应答报文如 404，402 等</p>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p>HyperText Markup Language 超文本标记语言<br>主要排版<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597647162793-f1d71c1f-0faa-4faf-a560-9bce9a3ff94e.jpeg" alt="-w630"></p>
<h2 id="FTP-amp-TFTP"><a href="#FTP-amp-TFTP" class="headerlink" title="FTP&amp;TFTP"></a>FTP&amp;TFTP</h2><p>FTP 可靠的面向连接的传输服务，基于 tcp<br>TFTP：基于 udp<br>主要步骤：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597647162595-548eff67-e932-44bb-90e0-08a1821675fa.jpeg" alt="-w424"></p>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>本地通过 tcp 登陆远端的另一台主机<br>将本地的进程运行在远端的主机上。</p>
<h2 id="SMTP-and-POP"><a href="#SMTP-and-POP" class="headerlink" title="SMTP and POP"></a>SMTP and POP</h2><p>smtp Simple Mail Transfer Protocol：邮件发送<br>pop3 Post Office Protocol version 3：邮件的接受<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647162241-23ea24c0-7469-46b4-ae44-22576e6b31fc.png" alt="A277F088-A3B2-4AEB-9927-4A1BFF14F95B"><br>MIME 标准 (Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型。（转化或扩充为 ascii）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597647162156-3ad7117c-ae2b-4d98-a622-3759f3a2dbfd.jpeg" alt="-w426"></p>
<p>mime 增加新的首部<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597647162590-d1e02d34-e5c5-4b65-90d1-2979988abefd.jpeg" alt="-w427"></p>
<h2 id="snmp"><a href="#snmp" class="headerlink" title="snmp"></a>snmp</h2><p>简单网络管理协议 The Simple Network Management Protocol<br>应用层协议（一般用 udp 实现）<br>对网络中的主机上网进行管理</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统（Domain Name System）<br>域名结构：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647162012-d6afe1af-fdf6-461a-bcd9-aaa52b4f7073.png" alt="A86E1A0F-9503-4F1E-A004-20C11C4CDD1B"><br>顶级域名 TLD：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647162848-2c96ae39-ecfa-4b44-960a-42033db3c549.png" alt="91B95111-C9DD-4686-94F6-8C8CD668FAA8"><br>从属关系<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597647162162-a3f97ffe-6550-4c81-afc7-412fbce838b0.png" alt="40848430-F874-4864-982C-A96FCD44F2FA"></p>
<h2 id="应用层通讯方法"><a href="#应用层通讯方法" class="headerlink" title="应用层通讯方法"></a>应用层通讯方法</h2><p>无上下文<br>保持连接</p>
<h2 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h2><p>Dynamic Host Configuration Protocol 动态主机配置协议，基于 udp。由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597650144912-9a363e6b-0ed0-478e-a348-5e897d629c8a.png" alt="53B0E06C-0BC1-4DB8-98F6-110E3A4FA8B1"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597650145117-906c6ddc-c8ac-41aa-99b9-8a4efc449717.png" alt="3B7418E4-B4F8-4F4B-BB3B-0AD3558DC601"><br>第二个广播 discover 报文是确定具体的服务器<br>发现阶段：DHCP Client 开始并不知道 DHCP Server 的 ip 地址,因此以广播的方式发出 DHCP Discover 报文<br>响应阶段：服务器在地址池中查找合法的 IP 地址，通过 DHCP offer 报文提供给 client<br>选择阶段： DHCP Client 选择一个 DHCP Offer 报文（一般选择最先收到的 DHCP Offer 报文），向网络发送一个 DHCP Request 广播数据包<br>租约确认阶段：DHCP Server 接收到 DHCP Request 消息后，以 DHCP ACK 消息向 DHCP Client 广播成功的 确认；出错则广播否定确认消息 DHCP NAK<br>租期续约：在租期中，DHCP Client 直接向为其提供 IP 地址的 DHCPServer 发送 DHCP Request 消息，收到回应的 DHCP ACK 消息后， DHCP Client 根据所提供的新的租期以及其它更新的 TCP/IP 参数更新自己的配置，IP 租用更新完成</p>
<p>报文结构：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597650145114-8ab85912-7b71-4cb4-a074-8542e901e3de.png" alt="2FB43B23-8448-4DE1-8E39-9F0114967B"><br>报文类型：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597650144891-36ac90cb-53b5-438f-bfda-36e7f6c53ee6.png" alt="D1EE87C6-688A-4CD5-959A-B0FD96F6DDF2"></p>
<h3 id="dhcp-欺骗原理"><a href="#dhcp-欺骗原理" class="headerlink" title="dhcp 欺骗原理"></a>dhcp 欺骗原理</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597650145046-1c10fecc-38c7-4f3c-8dd5-999153374fe0.jpeg" alt="-w501"></p>
<p>防范：在交换机上启用 DHCP Snooping 功能<br>DHCP Snooping 技术通过建立和维护 DHCP Snooping 绑定表过滤不可信任的 DHCP 信息</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第十章 广域网WAN</title>
    <url>/2020/08/29/hbgxc0/</url>
    <content><![CDATA[<h2 id="WAN-service"><a href="#WAN-service" class="headerlink" title="WAN service"></a>WAN service</h2><p>A WAN is the communications network that connects LANs through a WAN Service Provider<br>wan 操作一般处于物理层和数据链路层<br>CPE：customer premises equipment<br>CO：central office</p>
<h3 id="WAN-virtual-circuits"><a href="#WAN-virtual-circuits" class="headerlink" title="WAN virtual circuits"></a>WAN virtual circuits</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330206-d0f9581d-9f61-4b3a-aa1e-c1338b7d5d91.png" alt="5277BD7B-04B9-4973-BC80-A3AB04B27FDC"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843329842-74d23217-efae-424a-bea9-5c64e1be6df5.jpeg" alt="-w478"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330330-a2090cff-57f8-4947-a726-6ef61395a9d9.png" alt="7FD2777F-4BEF-4590-A978-F8373838"></p>
<h2 id="wan-设备"><a href="#wan-设备" class="headerlink" title="wan 设备"></a>wan 设备</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330034-14b56b39-d472-4ce0-8497-aeb0b6028a92.png" alt="CF7F5328-679D-458E-9366-3403E82E797E"><br>modem 将信号转换为运行商使用信号</p>
<h2 id="wan-模型"><a href="#wan-模型" class="headerlink" title="wan 模型"></a>wan 模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843329958-1c646543-88b1-4be9-add7-9624dc4e5a04.jpeg" alt="-w453"></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>DTE：data terminal equipment 用户的接入设备<br>DCE：data-circuit termination equipment 提供服务</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843337589-b9f314f0-0847-4ade-862c-cce6c5f8b7f6.jpeg" alt="-w590"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843337536-5fea32bb-3da5-4a8e-8742-dda14a82bcc4.png" alt="0B6D577C-82EB-4904-9CA6-4DEB41B5A2F7"></p>
<h2 id="wan-访问标准"><a href="#wan-访问标准" class="headerlink" title="wan 访问标准"></a>wan 访问标准</h2><h3 id="PPP-amp-HDLC"><a href="#PPP-amp-HDLC" class="headerlink" title="PPP&amp;HDLC"></a>PPP&amp;HDLC</h3><p>点对点 WAN 封装<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843329956-c1bb9547-81c5-4192-a975-0e066a924bab.png" alt="FFA4D29D-6F18-49B1-BE54-BA4FD32BDA19"><br>PPP is a standard serial-line encapsulation method。在同等单元之间传输数据包的第二层协议，提供全双工操作，并按照顺序传递数据包。<br>加入了身份认证 pap，挑战握手（chap）<br>hdlc：无窗口和流控制，两边设备都是思科的设备<br>支持动态 ip 分配<br>Link Control Protocol：连接建立，连接配置选项，连接质量测试<br>PPP 帧格式<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843337760-5c936a8f-2b10-4d42-88a9-5386a63b3e87.png" alt="CB8F46CB-D0D8-434B-9C67-A0BB6CA0346E"><br>lcp（准备建立连接）-》连接质量测试-〉ncp 网络层协议检测-》连接终止（请求终止/链路不能达到要求）</p>
<h4 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843330323-ba3cf6c5-957a-4681-855e-6f08cf132122.jpeg" alt="-w530"><br>明文方式发送，只在连接建立前认证</p>
<h4 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843330312-e884dff8-2ece-4ba8-9f76-b782b32f5928.jpeg" alt="-w534"><br>请求内容是密文</p>
<h3 id="ISDN"><a href="#ISDN" class="headerlink" title="ISDN"></a>ISDN</h3><p>Integrated Services Digital Networks 综合业务数字网<br>提供端到端的数字连接，以支持一系列的业务(包括话音和非话音业务)，为用户提供多用途的标准接口以接入网络。<br>可以携带音频，视频，和数据<br>服务：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843337674-3e8db78e-9af2-452b-adf4-a1a418867447.jpeg" alt="-w602"></p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330308-095fab44-e9c7-460b-bb8c-267fe698437b.png" alt="235CC8D8-4E3C-4AFE-B4A3-DAB777C219F4"></p>
<p>Asymmetric Digital Subscriber Line 非对称数字用户线<br>ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系（用户线越细，信号传输时的衰减就越 大），而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<br>ADSL 上行和下行带宽不对称。 ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制<br>解调器。</p>
<h4 id="DMT-Discrete-Multi-Tone-离散多音调"><a href="#DMT-Discrete-Multi-Tone-离散多音调" class="headerlink" title="DMT Discrete Multi-Tone 离散多音调"></a>DMT Discrete Multi-Tone 离散多音调</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843330354-52f406de-499f-4726-8321-634929f6b1fa.jpeg" alt="-w443"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330362-d9643ad5-8a93-49b2-8fe7-8fe69b3aa1d6.png" alt="F02B6212-7863-4A49-BE1F-07DF6FAE7A80"></p>
<h3 id="SONET"><a href="#SONET" class="headerlink" title="SONET"></a>SONET</h3><p>(Synchronous Optical Network）同步光纤网<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843329971-e88bef93-1d89-4cb8-b211-5816f34b5b1c.jpeg" alt="-w468"><br>同步数字系列 SDH<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843337554-99302dff-33c4-4230-85e9-13327e1349b4.jpeg" alt="-w514"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843337549-ae1f6a5e-6f3e-4ca0-8f7f-2487cef1c937.jpeg" alt="-w423"></p>
<h3 id="HFC"><a href="#HFC" class="headerlink" title="HFC"></a>HFC</h3><p>光纤同轴混合网 (Hybrid Fiber Coax)<br>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。<br>主要特点：主干路采用光纤，采用结点体系结构，频谱更宽，双向传输<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843330308-0a51556a-5692-490b-bfde-8fed75ea1555.jpeg" alt="-w477"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597843337549-79a39a97-ffe2-47bf-8025-6585ec4d7cde.jpeg" alt="-w476"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597843330285-dfde1cc8-7d2d-47fd-9abf-0018cd669706.png" alt="1DC01E11-C2FA-4528-A513-4ECE586B4A"></p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第七章 路由和路由器</title>
    <url>/2020/08/29/hqwqwc/</url>
    <content><![CDATA[<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>特定的计算机<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597650335769-f087d406-d0e8-4ad1-954f-4120d7354765.jpeg#align=left&display=inline&height=388&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=828&status=done&style=none&width=828" alt=""></p>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>Random Access Memory 随机存取存储器/主存。 与 cpu 直接交互数据。一断电数据会丢失。访问快。<br>存储：Routing tables ，ARP cache ， Fast switching cache ， Packet buffering ， Packet hold queue</p>
<h3 id="NVRAM"><a href="#NVRAM" class="headerlink" title="NVRAM"></a>NVRAM</h3><p>Non-volatile RAM 非易失。<br>存放配置信息（backup/startup configuration）。（关机不会丢失）</p>
<h3 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h3><p>EEPROM (Electronically Erasable Programmable Read-Only Memory)</p>
<h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>Read-Only Memory 只读存储器<br>一般存储： post（power on self test）开机自检，检测硬件无误。</p>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597650335763-ae11fdc4-fcb8-4812-8005-532286413978.jpeg#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&originHeight=228&originWidth=696&status=done&style=none&width=696" alt=""></p>
<h2 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h2><p>1.post 硬件出错会发出声音提示 2.确认 cpu，存储，接口 3.软件初始化<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597650336228-45d0d964-ca87-4df0-905a-99f22b902ebb.png#align=left&display=inline&height=492&margin=%5Bobject%20Object%5D&originHeight=492&originWidth=868&status=done&style=none&width=868" alt=""></p>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>administrative distance is a rating of the trustworthiness of a routing information source, expressed as a numeric value from 0<br>to 255.<br>The higher the number, the lower the trustworthiness rating.</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>Time to Convergence 收敛时间。发生变化到稳定状态。<br>时间越短，对应的动态路由协议越强<br>路由回路解决：设置最大值，路由毒化，水平分割，设置计时器</p>
<h4 id="定义最大值"><a href="#定义最大值" class="headerlink" title="定义最大值"></a>定义最大值</h4><p><a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/9720208" target="_blank" rel="noopener">距离矢量路由算法</a>可以通过 IP 头中的生存时间（TTL）自纠错，但路由环路问题可能首先要求无穷计数。为了避免这个延时问题，<a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">距离矢量协议</a>定义了一个最大值，这个数字是指最大的<a href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F%E5%80%BC" target="_blank" rel="noopener">度量值</a>（最大值为 16），比如跳数。也就是说，路由更新信息可以向不可到达的网络的路由中的路由器发送 15 次，一旦达到最大值 16，就视为网络不可到达，存在故障，将不再接受来自访问该网络的任何路由更新信息。</p>
<h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>一种消除路由环路并加快网络收敛的方法是通过叫做“水平分割”的技术实现的。其规则就是不向原始路由更新来的方向再次发送路由更新信息（个人理解为单向更新，单向反馈）。比如有三台路由器 ABC，B 向 C 学习到访问网络 10.4.0.0 的路径以后，不再向 C 声明自己可以通过 C 访问 10.4.0.0 网络的路径信息，A 向 B 学习到访问 10.4.0.0 网络路径信息后，也不再向 B 声明，而一旦网络 10.4.0.0 发生故障无法访问，C 会向 A 和 B 发送该网络不可达到的路由更新信息，但不会再学习 A 和 B 发送的能够到达 10.4.0.0 的错误信息。</p>
<h4 id="路由中毒"><a href="#路由中毒" class="headerlink" title="路由中毒"></a>路由中毒</h4><p>（也称为路由毒化）<br>定义最大值在一定程度上解决了路由环路问题，但并不彻底，可以看到，在达到最大值之前，路由环路还是存在的。为此，路由中毒就可以彻底解决这个问题。其原理是这样的：假设有三台<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="noopener">路由器</a>ABC，当网络 10.4.0.0 出现故障无法访问的时候，路由器 C 便向邻居路由发送相关路由更新信息，并将其<a href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F%E5%80%BC" target="_blank" rel="noopener">度量值</a>标为无穷大，告诉它们网络 10.4.0.0 不可到达，路由器 B 收到毒化消息后将该链路<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%A1%A8" target="_blank" rel="noopener">路由表</a>项标记为无穷大，表示该路径已经失效，并向邻居 A 路由器通告，依次毒化各个路由器，告诉邻居 10.4.0.0 这个网络已经失效，不再接收更新信息，从而避免了路由环路。</p>
<h4 id="反向中毒"><a href="#反向中毒" class="headerlink" title="反向中毒"></a>反向中毒</h4><p>（也称为毒化逆转）<br>结合上面的例子，当路由器 B 看到到达网络 10.4.0.0 的度量值为无穷大的时候，就发送一个叫做毒化逆转的更新信息给 C 路由器，说明 10.4.0.0 这个网络不可达到，这是超越<a href="https://baike.baidu.com/item/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2" target="_blank" rel="noopener">水平分割</a>的一个特列，这样保证所有的路由器都接受到了毒化的路由信息。</p>
<h4 id="控制更新时间"><a href="#控制更新时间" class="headerlink" title="控制更新时间"></a>控制更新时间</h4><p>（即抑制计时器）<br>抑制计时器用于阻止定期更新的消息在不恰当的时间内重置一个已经坏掉的路由。抑制计时器告诉路由器把可能影响路由的任何改变暂时保持一段时间，抑制时间通常比更新信息发送到整个网络的时间要长。当路由器从邻居接收到以前能够访问的网络不能访问的更新后，就将该路由标记为不可访问，并启动一个抑制计时器，如果再次收到从邻居发送来的更新信息，包含一个比原来路径具有更好<a href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F%E5%80%BC" target="_blank" rel="noopener">度量值</a>的路由，就标记为可以访问，并取消抑制计时器。如果在抑制计时器超时之前从不同邻居收到的更新信息包含的度量值比以前的更差，更新将被忽略，这样可以有更多的时间让更新信息传遍整个网络。</p>
<h4 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h4><p>正常情况下，<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="noopener">路由器</a>会定期将<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%A1%A8" target="_blank" rel="noopener">路由表</a>发送给邻居路由器。而触发更新就是立刻发送路由更新信息，以响应某些变化。检测到<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/1391028" target="_blank" rel="noopener">网络故障</a>的路由器会立即发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，使整个网络上的路由器在最短的时间内收到更新信息，从而快速了解整个网络的变化。但这样也是有问题存在，有可能包含更新信息的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener">数据包</a>被某些网络中的链路丢失或损坏，其他路由器没能及时收到触发更新，因此就产生了结合抑制的触发更新，抑制规则要求一旦路由无效，在抑制时间内，到达同一目的地有同样或更差<a href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F%E5%80%BC" target="_blank" rel="noopener">度量值</a>的路由将会被忽略，这样触发更新将有时间传遍整个网络，从而避免了已经损坏的路由重新插入到已经收到触发更新的邻居中，也就解决了路由环路的问题。</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第九章 交换机和vlan</title>
    <url>/2020/08/29/lhnnbi/</url>
    <content><![CDATA[<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>生成并维护基于 mac 地址的 switch table<br>对帧 swtich<br>非对称交互技术<br>Memory Buffering：传输阻塞时，对帧进行缓存<br>Port-based memory buffering。可能会造成端口阻塞<br>Shared memory buffering<br>switch：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597715724271-3a02b6bb-c0ae-45c8-8ee5-55d0e98a1988.jpeg" alt="-w496"><br>识别三种方法：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597715724170-a41f4a74-e31a-4931-a73d-c424150d7e92.png" alt="2413870D-8654-4B3D-AB24-B41DF295A522"><br>一个二层交换机一般有一个 mac 地址，来做配置处理<br>三层交换机（基于硬件，mac 地址和 ip 地址映射不通过路由）</p>
<h2 id="spanning-tree-protocol"><a href="#spanning-tree-protocol" class="headerlink" title="spanning -tree protocol"></a>spanning -tree protocol</h2><p>在一个生成树环境里，桥不会立即开始转发功能，它们必须首先选择一个桥为根桥，然后建立一个指定路径。在一个网络里边拥有最低桥 ID 的将变成一个根桥，全部的生成树网络里面只有一个根桥。</p>
<h3 id="brdging-loops-桥接环路"><a href="#brdging-loops-桥接环路" class="headerlink" title="brdging loops 桥接环路"></a>brdging loops 桥接环路</h3><p>一般来说，环路是主动提供冗余造成的，也可能是配置错误（broadcast loops， bridge-table corruption）</p>
<h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><p>主要功能：物理上允许冗余电路存在，但是会禁用部分端口<br>Spanning-tree frames（ bridge protocol data units–BPDUs）来决定生成树的拓扑</p>
<h3 id="STP-决定顺序"><a href="#STP-决定顺序" class="headerlink" title="STP 决定顺序"></a>STP 决定顺序</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597715723997-eaa7a17e-48db-4b90-b0e8-902f6d31c08a.png" alt="8FAFF6A4-B46F-449F-8A51-4BDA3C4392A0"> 1.选举根桥 2.确定根端口 3.确定指定端口<br>STP 将选举 BID 最小的交换机为整个交换域的根交换机<br>选择好根桥后将选举根端口，STP 将以根交换机为 cost 0 点，其他每个交换机都将选择一 个根端口。根端口选择依据为到根交换机 cost 最小的端口。 指定端口既存在于根桥上也存在于非根桥上，对于根桥来说每个端口都为指定端口。对于非 根桥来说，需要与根桥通讯的端口被选为指定端口。<br>指定端口选举才用 cost 值的方式。如果 cost 相同则比较 BID 与 PID</p>
<h3 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597715724206-01626925-af5e-456f-b5e3-cc3c6394d918.png" alt="E6FD01DB-FEA5-4AF1-A525-3A450401CCCE"><br>BPDU 字段<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597715724040-2693519f-3ecd-490b-9d5a-4e7e09e8e151.png" alt="870CED53-6CBD-4B39-8015-88AABEAE3C4C"></p>
<h4 id="BID"><a href="#BID" class="headerlink" title="BID"></a>BID</h4><p>8bytes：前两个字节是优先级 0-65,535 (default: 32768) 。用十进制表示<br>后六个字节是 mac 地址，用十六进制表示。<br>The switches elect a single root switch by looking for the switch with the lowest BID<br>bid 越低越好。</p>
<h4 id="path-cost"><a href="#path-cost" class="headerlink" title="path cost"></a>path cost</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597715723993-4533ccd4-029c-4d92-89f4-770efd0bed52.jpeg" alt="-w350"></p>
<h4 id="5-种-STP-状态"><a href="#5-种-STP-状态" class="headerlink" title="5 种 STP 状态"></a>5 种 STP 状态</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597715724256-5bdcee43-c1a3-456e-a3b2-32b162dff8f1.jpeg" alt="-w488"></p>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>VLAN（Virtual Local Area Network）虚拟局域网<br>LAN 划分基于物理位置，VLAN 基于逻辑<br>Broadcast frames are only switched between ports on the switch or switches with the same VLAN ID.<br>可划分依据：port number MAC address protocol being used application being used<br>VLAN 中继：可以支持不同 VLANid</p>
<h3 id="vlan-结构"><a href="#vlan-结构" class="headerlink" title="vlan 结构"></a>vlan 结构</h3><p>backbone：两个相连的路由器/交换机<br>路由器起到连接作用</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>帧过滤<br>帧标记</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>静态 vlan，动态 vlan<br>连接：access trunk<br>access link：交换机只有一个 vlan<br>trunk link：交换机/路由器连接多个 vlan</p>
]]></content>
  </entry>
  <entry>
    <title>第二章 物理层</title>
    <url>/2020/08/29/itreq7/</url>
    <content><![CDATA[<h2 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h2><ul>
<li>share media 不同的主机访问相同的介质。</li>
<li>point to point</li>
</ul>
<h2 id="LAN-media"><a href="#LAN-media" class="headerlink" title="LAN media"></a>LAN media</h2><p>传输数据，通过将数据编译成字节码来传递</p>
<h3 id="UTP-双绞线"><a href="#UTP-双绞线" class="headerlink" title="UTP 双绞线"></a>UTP 双绞线</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372367331-f1a8620c-0266-4cd9-b5c4-741adc5890f6.jpeg#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=746&status=done&style=none&width=746" alt=""><br>有效 100m<br>优点：容易部署，便宜<br>缺点：抵抗噪音能力较弱，避免大功率电器在其附近，电阻大，电流损耗明显</p>
<h3 id="coaxial-同轴电缆"><a href="#coaxial-同轴电缆" class="headerlink" title="coaxial 同轴电缆"></a>coaxial 同轴电缆</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372367651-ac99d2b7-fba3-48b9-b547-3882f7fd1d99.jpeg#align=left&display=inline&height=680&margin=%5Bobject%20Object%5D&originHeight=680&originWidth=750&status=done&style=none&width=750" alt=""><br>分为细缆和粗缆。前者电阻大传输距离近，后者成本大</p>
<h3 id="fiber-光缆"><a href="#fiber-光缆" class="headerlink" title="fiber 光缆"></a>fiber 光缆</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372367536-c146bd69-9487-447b-8baf-7f1cf5a51b94.png#align=left&display=inline&height=612&margin=%5Bobject%20Object%5D&originHeight=612&originWidth=682&status=done&style=none&width=682" alt=""><br>分为：<br>single mode：几乎无反射，能量亏损少<br>multimode：多用于 lan</p>
<h3 id="无线通讯"><a href="#无线通讯" class="headerlink" title="无线通讯"></a>无线通讯</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372368378-b7707cab-ceb6-4f07-bfbf-2b3b39782cea.png#align=left&display=inline&height=682&margin=%5Bobject%20Object%5D&originHeight=682&originWidth=1136&status=done&style=none&width=1136" alt=""></p>
<h2 id="UTP-for-Ethernet"><a href="#UTP-for-Ethernet" class="headerlink" title="UTP for Ethernet"></a>UTP for Ethernet</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372369299-a9a3ee31-f4ce-4e6d-ba96-db9d2bcd2adc.png#align=left&display=inline&height=690&margin=%5Bobject%20Object%5D&originHeight=690&originWidth=1170&status=done&style=none&width=1170" alt=""></p>
<h3 id="cable-type"><a href="#cable-type" class="headerlink" title="cable type"></a>cable type</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372369314-ff22cf14-2ddd-4b99-b38c-33a7a3fdc686.png#align=left&display=inline&height=544&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=1300&status=done&style=none&width=1300" alt=""></p>
<p>Straight Cable 直通线 两端都是 T568A 或者 T568B   host 与 switch，switch 与 router 相连<br>Rollover Cable 反转线 一端是 1 ～ 8 另一段 8 ～ 1。将 pc 作为路由器控制台时使用.在 pc 端加一个适配器（pc 对应有 super terminal 的程序）<br>Crossover Cable 交叉线 一端是 t568A 一端是 B。一般，两个相同的设备。（连接两个交换机两个 8 口合并为 14 口的</p>
<h3 id="物理层介质和信号"><a href="#物理层介质和信号" class="headerlink" title="物理层介质和信号"></a>物理层介质和信号</h3><h4 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h4><p>传播：通量=数据/事件<br>衰减：有限长度传输<br>反射：终点要做特定处理<br>噪音：来自于电磁波和脉冲<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372370115-718150cf-b93b-4abd-abd9-dc6d472b8ff4.jpeg#align=left&display=inline&height=706&margin=%5Bobject%20Object%5D&originHeight=706&originWidth=1306&status=done&style=none&width=1306" alt=""></p>
<h3 id="冲突和冲突域"><a href="#冲突和冲突域" class="headerlink" title="冲突和冲突域"></a>冲突和冲突域</h3><p>冲突发生在两段数据在同一网络和同一时间传播。无法在第一层解决<br>冲突域通过 hub 和 repeater 进行了延展。<br>网络可以被划分为段才可以解决冲突。分段不代表分为不同的 lan</p>
<h2 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p>信号 signal：数据的电气的或电磁的表现。</p>
<ul>
<li>模拟————取值是连续的</li>
<li>数字————取值是离散的<br>码元（code）：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>模拟信号分为简单信号（正弦波）不能被分解 和 复合信号（可以分解多个正弦波）<br>数据信号一般是非周期性的，在介质上表现为<br>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重（码间串扰）<br>无噪声信道最高传输速率<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372367094-02f76a01-822f-4adf-b1f1-856283ad765c.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=1202&status=done&style=none&width=1202" alt=""></p>
<p>噪声信道最高传输速率<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372368342-596d388f-c73c-441c-bd65-017f6c9d1cff.png#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1108&status=done&style=none&width=1108" alt=""><br>信道带宽或信道的信噪比越大，极限传输速率越高<br>只要信息传输速率低于信道的极限信息传输速率，就一定有办法实现无差错的传输<br>若信道的带宽 W 或信噪比 S/N 没有上限（实际不可能），则其极限信息传输速率 C 也没有上限<br>实际能够达到的传输速率比香农极限传输速率低不少<br>请注意：对于频带宽度已确定的信道，即使信噪比不能再提高，且码元速率已达上限，也有办法提高传输速率。这就是用编码的方法让每个码元携带更多比特的信息量</p>
<h4 id="bit-和-baud"><a href="#bit-和-baud" class="headerlink" title="bit 和 baud"></a>bit 和 baud</h4><p>比特率：每秒传送的二进制位数<br>波特率：信号每秒变化的次数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372369160-bfdf36b3-6ffb-4522-bc54-48c1ccf6dcd9.png#align=left&display=inline&height=846&margin=%5Bobject%20Object%5D&originHeight=846&originWidth=1470&status=done&style=none&width=1470" alt=""></p>
<h3 id="数字数据编码"><a href="#数字数据编码" class="headerlink" title="数字数据编码"></a>数字数据编码</h3><p>基带：基本频带。指传输变换前所占用的频带，是原始信号固有的频带<br>基带传输：直接使用基带传输<br>调制：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372370114-122c762f-8b0e-4816-bf2a-f40f78f5db31.jpeg#align=left&display=inline&height=694&margin=%5Bobject%20Object%5D&originHeight=694&originWidth=1422&status=done&style=none&width=1422" alt=""></p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><h4 id="单极性编码"><a href="#单极性编码" class="headerlink" title="单极性编码"></a>单极性编码</h4><h4 id="极化编码"><a href="#极化编码" class="headerlink" title="极化编码"></a>极化编码</h4><h4 id="双极性编码"><a href="#双极性编码" class="headerlink" title="双极性编码"></a>双极性编码</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372369167-b752618b-be76-47c4-8073-574bbbca6f83.png#align=left&display=inline&height=1476&margin=%5Bobject%20Object%5D&originHeight=1476&originWidth=664&status=done&style=none&width=664" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372369652-b6369d7f-f14a-44d8-b2ff-8fafbb4c445b.png#align=left&display=inline&height=1886&margin=%5Bobject%20Object%5D&originHeight=1886&originWidth=664&status=done&style=none&width=664" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597372367288-d6cc43b3-d9de-460f-8028-ce99060fcb54.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=660&status=done&style=none&width=660" alt=""></p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用 TDM"></a>时分复用 TDM</h4><p>将时间划分为等长的 TDM 帧。每个用户在帧中占用固定序号的时隙<br>每个用户所占时隙是周期性出现的<br>TDM 信号也称为等时(isochronous)信号。<br>时分复用的所有用户在不同的时间占用同样的频带宽度<br>但可能造成线路资源的浪费<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372368360-d96b7dc9-180d-479b-81aa-d31b6894500c.jpeg#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=904&status=done&style=none&width=904" alt=""></p>
<p>统计时分复用 stdm<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372368363-2f01af6f-fe05-4996-ba4d-b1d84d79bef2.jpeg#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=904&status=done&style=none&width=904" alt=""></p>
<h4 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用 FDM"></a>频分复用 FDM</h4><p>在分配到一定频带后始终占用该频带（频率带宽）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372367369-ef035fc3-24c2-425b-ad21-b71d3140d834.jpeg#align=left&display=inline&height=342&margin=%5Bobject%20Object%5D&originHeight=342&originWidth=880&status=done&style=none&width=880" alt=""></p>
<h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597372369704-a2ccf142-4a9d-421c-99ea-a08f81518eb1.jpeg#align=left&display=inline&height=706&margin=%5Bobject%20Object%5D&originHeight=706&originWidth=1000&status=done&style=none&width=1000" alt=""></p>
<h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><p>常用的名词是码分多址 CDMA(Code Division Multiple Access)<br>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第十一章 网络安全</title>
    <url>/2020/08/29/izctoi/</url>
    <content><![CDATA[<h2 id="网络安全问题概述"><a href="#网络安全问题概述" class="headerlink" title="网络安全问题概述"></a>网络安全问题概述</h2><p>四种威胁<br>(1) 截获——从网络上窃听他人的通信内容。<br>(2) 中断——有意中断他人在网络上的通信。<br>(3) 篡改——故意篡改网络上传送的报文。<br>(4) 伪造——伪造信息在网络上传送<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597841076922-b209d5fd-1ce1-40ae-a0aa-1b599a4cc075.png" alt="979463B0-2554-417D-B776-B64EEEF213"><br>在被动攻击中，攻击者只是观察和分析某一个协议数据单元 PDU 而不干扰信息流。<br>主动攻击是指攻击者对某个连接中通过的 PDU 进行各种处理。<br>更改报文流 拒绝报文服务 伪造连接初始化</p>
<h3 id="网络通信安全目标："><a href="#网络通信安全目标：" class="headerlink" title="网络通信安全目标："></a>网络通信安全目标：</h3><p>防止析出报文内容， 防止通信量分析， 检测更改报文流， 检测拒绝报文服务， 检测伪造初始化连接</p>
<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597841077035-f645ec84-0ff1-4201-996c-d9989955b1b4.png" alt="6BBA02CD-E65A-4081-B01D-080E5E89B458"></p>
<h3 id="网络安全内容"><a href="#网络安全内容" class="headerlink" title="网络安全内容"></a>网络安全内容</h3><p>保密性，安全协议的设计，访问控制</p>
<h2 id="一般的数据加密模型"><a href="#一般的数据加密模型" class="headerlink" title="一般的数据加密模型"></a>一般的数据加密模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841076947-cacffc59-eece-4eae-ae17-1ad6a738d4ec.jpeg" alt="-w439"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841077063-800bce10-5055-424c-9656-6aa2e2ca2417.jpeg" alt="-w379"></p>
<h2 id="对称密钥和公钥密码体制"><a href="#对称密钥和公钥密码体制" class="headerlink" title="对称密钥和公钥密码体制"></a>对称密钥和公钥密码体制</h2><h3 id="对称密钥密码体制-常规密钥密码体制"><a href="#对称密钥密码体制-常规密钥密码体制" class="headerlink" title="对称密钥密码体制/常规密钥密码体制"></a>对称密钥密码体制/常规密钥密码体制</h3><p>加密密钥与解密密钥是相同的密码体制</p>
<h4 id="DES-数据加密标准"><a href="#DES-数据加密标准" class="headerlink" title="DES 数据加密标准"></a>DES 数据加密标准</h4><p>Data Encryption Standard<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597841077017-7de1a3e9-3814-43cd-aa37-10445ae86949.png" alt="E4C62F26-12B8-47C1-B40C-5E2732295C80"><br>破译最有效方法：穷举法<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841076960-50c6d97d-f606-4d2e-9608-086447ab3728.jpeg" alt="-w346"></p>
<h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>由已知加密密钥推导出解密密钥在计算上是不可行的<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841077110-5a07e283-3505-4d29-817a-12a46023f1c7.jpeg" alt="-w442"></p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841077001-3c115ee9-c934-4585-bd48-2ef629bd5618.jpeg" alt="-w371"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841076996-f0fb624d-17b8-4469-8111-2bf519064328.jpeg" alt="-w447"></p>
<h2 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙 firewall"></a>防火墙 firewall</h2><p>防火墙是由软件、硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略<br>Access Control Lists（访问控制列表）<br>acl 必须配置在路由器上否则路由器会允许所有的访问<br>deny/permit 依据：<br>source add，destination add， upper layer protocols</p>
<p>如果没有符合的语句匹配 If no statement matches, what happens?<br>Deny all these packets!<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597841077052-258e5c59-417a-4791-9f17-8d3731acbecd.jpeg" alt="-w395"></p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>考试总结</title>
    <url>/2020/08/29/uxizhn/</url>
    <content><![CDATA[<h2 id="大题题型："><a href="#大题题型：" class="headerlink" title="大题题型："></a>大题题型：</h2><ol>
<li>子网划分：<a href="https://blog.csdn.net/NordesertWolf/article/details/51564071?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/NordesertWolf/article/details/51564071?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></li>
<li>ip 聚合 <a href="https://blog.51cto.com/1318643/870551" target="_blank" rel="noopener">https://blog.51cto.com/1318643/870551</a></li>
<li>编码</li>
<li>路由表</li>
<li>frame，packet，segment，data 结构</li>
<li>TCP 的三次四次握手</li>
<li>TCP/IP 模型和 osi 的异同</li>
<li>路由转发<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597807273523-f2eab25b-1a9a-4e6d-8f7e-58abe8180626.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1392&size=405244&status=done&style=none&width=696" alt="image.png"></li>
<li></li>
</ol>
<p>##</p>
<h2 id="2010-年考试"><a href="#2010-年考试" class="headerlink" title="2010 年考试"></a>2010 年考试</h2><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><p>区别每个层次的协议，routed 和 routing protocols<br>冲突域个数=交换机连接的 pc 和集线器+路由器连接的交换机<br>第一层介质/网线的类别 100basetx<br>以太网的核心协议<br>root bridge<br>OSPF Hello packets are addressed to 224.0.0.5<br>以太网介质访问控制：CSMA/CD<br>交换机不需要手动配置，可以自己学习连接其的主机 mac 地址，并为其分配端口<br>mac 地址 48 位。前 6 位 16 进制数代表网络硬件制造商的编号，它由<a href="https://baike.baidu.com/item/IEEE/150905" target="_blank" rel="noopener">IEEE</a>(电气与电子工程师协会)分配，而后 6 位 16 进制数代表该制造商所制造的某个网络产品(如网卡)的系列号。<br>startup 存在路由器的 NVRAM 中</p>
<h2 id="2013-年考试"><a href="#2013-年考试" class="headerlink" title="2013 年考试"></a>2013 年考试</h2><p>MAC:802.3<br>LLC:802.2<br>Wireless LAN Standard IEEE 802.11 系列<br>PDU 协议数据单元。在 osi 中，每一层都将建立协议数据单元<br>当 mac 地址不在 switching table 里时，帧将会泛洪到所有端口<br>ISDN BRI-B 速率是 64kps<br>CSMA/CD 和 CSMA/CA 区别：<a href="https://blog.csdn.net/ljh618625/article/details/86151428" target="_blank" rel="noopener">https://blog.csdn.net/ljh618625/article/details/86151428</a><br>FTP 服务要有两个端口:21 端口负责发起和建立双方的连接，20 端口负责传输数据。<br>PAP 和 CHAP 区别：<a href="https://blog.csdn.net/santtde/article/details/83650128?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/santtde/article/details/83650128?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h2 id="2015-考试"><a href="#2015-考试" class="headerlink" title="2015 考试"></a>2015 考试</h2><p>端口号范围：0 ～ 65535<br>UTP 的特点</p>
<p>IPv4 和 IPv6 的区别(IPv4 的地址是 32 位的，IPv6 的地址是 128 位的)<br>静态路由和动态路由区别。静态节省了 CPU、带宽和路由内存，具有更高的安全性<br>交换机学习不到广播地址：广播地址不会是帧的源地址<br>交叉线和直通线区别：直通线用来连接不同设备，交叉线连接相同设备。<br>pc 有路由功能，属于三层设备。需要交叉线连接，不在同一个网段中。<br>可靠性最高的拓扑：网形拓扑</p>
<h2 id="2017-年考试"><a href="#2017-年考试" class="headerlink" title="2017 年考试"></a>2017 年考试</h2><p>路由器从某个接⼝接收到的更新信息不允许再从这个接口发回去<br>电路毒化：路由信息在路由表中失效的时候，把该表项的的度量值设为⽆穷大<br>nat 中一个 IP 地址供多个用户使用：pat<br>RIP v1 和 v2 区别：1.RIPv1 是有类路由协议，RIPv2 是无类路由协议<br>2.RIPv1 不能支持 VLSM，RIPv2 可以支持 VLSM<br>3.RIPv1 没有认证的功能，RIPv2 可以支持认证，并且有明文和 MD5 两种认证<br>4.RIPv1 没有手工汇总的功能，RIPv2 可以在关闭自动汇总的前提下，进行手工汇总<br>5.RIPv1 是广播更新，RIPv2 是组播更新，<br>6.RIPv1 对路由没有标记的功能，RIPv2 可以对路由打标记（tag），用于过滤和做策略<br>7.RIPv1 发送的 updata 最多可以携带 25 条路由条目，RIPv2 在有认证的情况下最多只能携带 24 条路由<br>8.RIPv1 发送的 updata 包里面没有 next-hop 属性，RIPv2 有 next-hop 属性，可以用与路由更新的重定</p>
<p>私有地址：私有地址就是在互联网上不使用，而被用在局域网中的地址<br>A 中：10.0.0.0 到 10.255.255.255；<strong>B：</strong>172.16.0.0 到 172.31.255.255；C：192.0.0.0 到 223.255.255.255</p>
<h2 id="2019-年考试"><a href="#2019-年考试" class="headerlink" title="2019 年考试"></a>2019 年考试</h2><p>socket 格式（ip 地址：端口）<br>使用 tcp 的协议</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 传输层transport layer</title>
    <url>/2020/08/29/ufozxg/</url>
    <content><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>将数据分为数据段（segment）<br>建立端到端的操作<br>发送数据段<br>流控制与可靠性，出错会重新传送（第二层会直接抛弃），保证通讯有效性</p>
<p>传输层将信息分段，对信息在目的站点重新聚集</p>
<h3 id="第四层主要协议"><a href="#第四层主要协议" class="headerlink" title="第四层主要协议"></a>第四层主要协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631605026-16f45645-05e8-4743-b86e-af6744fbd692.jpeg" alt="-w375"><br>acknowledge 会消耗大量时间<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597635598730-b118c16c-2497-4b76-8775-79e547fd975b.png" alt="E5A89FBD-2BC0-4D4A-80BA-4E9E0C351BC0"></p>
<h3 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h3><p>进程的复用。（逻辑上）<br>port：网络操作的指示符。<br>基于端口的不同，分发给不同进程。（同一个主机可以有很多进程去上网）<br>端口取值范围：0 ～ 65535。两个字节<br>0 ～ 255:public，分配给公认的应用程序。<br>0 ～ 123；熟知端口<br>1024 ～ 49151：需要登记。<br>49151:客户端程序<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597633980336-21f9f5b3-bdbc-406a-811e-7cc74ed1be1f.png" alt="A3231AD9-53EE-479E-AC72-32828555C40E"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597635598792-bc5c0b4e-9a27-47f9-a921-a0085349d70f.png" alt="384169D3-4E32-4F23-BAA5-E12FC375AE0D"></p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>第四层通讯单位：进程<br>socket=IPaddress + port</p>
<h2 id="TCP-Transmission-Control-protocol"><a href="#TCP-Transmission-Control-protocol" class="headerlink" title="TCP Transmission Control protocol"></a>TCP Transmission Control protocol</h2><p>可靠传输，流控制（基于窗口，避免拥塞）<br>不提供多播和广播服务</p>
<h3 id="TCP-数据段"><a href="#TCP-数据段" class="headerlink" title="TCP 数据段"></a>TCP 数据段</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631604878-26d1efc9-0f03-4e51-9296-36f961b21c43.png" alt="7DFF1504-6468-438F-A9CC-2FDA6B142044"><br>端口：源端口和目的端口各占两个字节，端口是运输层和应用层的服务接口。运输层的复用和分用功能都要通过端口来实现。<br>序号（Seq）：4bytes。序号字段的值指本报文段所发送的数据的第一个字节的序号。（保证传输的可靠）<br>确认号（Ack）：4bytes。期望收到对方的下一个报文的数据的第一个字节的序号<br>确认方 Ack=发起方 Seq+1，<br>数据偏移：4bytes。首部的长度。填充使首部是 4 的整数倍<br>保留位：6bit。今后使用<br>URG：紧急。0 正常，1 紧急指针有效，此报文段中有紧急数据，应尽快传输<br>ACK：1 确认号字节有效，0 确认号字节无效（初始时）<br>PSH：推送。1 尽快提交给接受应用进程，而不再等到缓存填满了后再向上交付<br>RST：复位。1TCP 连接出现严重差错，必须释放连接，再重新建立运输连接<br>SYN：同步 1 连接请求或连接接受报文<br>FIN：终止 1 此报文段发送段数据已发送完毕，并请求释放运输连接<br>窗口：2bytes：用来让对方设置发送窗口的依据。（允许对方的发送量）<br>检验和：2bytes。包含首部和数据部分以及伪首部。<br>紧急指针：<br>选项：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631604862-06c8b25d-3308-4eda-8bb3-4d97485d7270.jpeg" alt="-w527"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：serve 先启动，client 启动。client 发送连接请求创建 syn=1，ACK=0 的 TCP 段。<br>第二次握手：client 判断请求。拒绝（RST=1）。接受 SYN=1，ACK=1<br>第三次握手：server 发送是 syn=0 和 ACK=1 的数据段去确认连接</p>
<p>之后做数据传输<br>状态：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631604942-616d7735-785f-41c3-9134-38bdf886b654.png" alt="04D36C13-5E95-4A02-B4BF-67BF4DF45801"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631604863-1d21c5c1-695d-4a6d-a7aa-4438fc261c80.png" alt="A2815A00-D5C6-4EAE-976D-A7F6FB8520AA"></p>
<h3 id="传输控制-stop-wait-protocol"><a href="#传输控制-stop-wait-protocol" class="headerlink" title="传输控制 stop-wait-protocol"></a>传输控制 stop-wait-protocol</h3><p>应答丢失：重新发送。计时器设置的时间比平均往返时间长<br>应答超时：丢弃应答<br>ARQ Automatic Repeat reQuest<br>不需要等待应答的通知。未按时收到应答，直接发送<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631604979-61e23085-d58c-48ef-b7fb-06816f72c186.png" alt="69DCA02B-B0F9-4788-BFC9-59C697965F7E"><br>窗口是双方协议的。<br>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631605160-0d631393-40fc-4909-b68c-d3dc8e931e25.jpeg" alt="-w573"><br>win=0 停止发送。</p>
<h3 id="四次握手-连接断开"><a href="#四次握手-连接断开" class="headerlink" title="四次握手/连接断开"></a>四次握手/连接断开</h3><p>第一次：client 发送 Fin=1，client 半关闭，server 半关闭并通知上层<br>第二次：server 发送 ACK=1，<br>第三次：之前的数据未发送完，server 发送 fin=1，ACK=1<br>第四次：client 发送 ACK=1，应答<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631605032-22069d30-956d-425e-b9ba-db7935c6b8ce.png" alt="3C75DB04-56DF-46CE-AB24-856705A8CD41"><br>waittime：可能第三次未到达<br>msl：最大往返时间<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631605165-466fddc8-d445-4914-8fb0-511ad20478c7.png" alt="F0DF5191-3D0E-4BDE-A6F9-A4929AFCE0F3"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631605145-8e2ea679-59f3-445a-92ea-9cb9ba30bac8.jpeg" alt="-w627"></p>
<h3 id="TCP-的计时器"><a href="#TCP-的计时器" class="headerlink" title="TCP 的计时器"></a>TCP 的计时器</h3><p>重传计时器，<br>坚持计时器（避免死锁，检查窗口是否是 win=0）<br>保持计时器（通讯双方释是否继续保持连接）<br>时间等待计时器（第四次握手计时器）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631605179-cae81749-db1f-475f-bb2c-3da87c17fca7.jpeg" alt="-w533"></p>
<h2 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP(User Datagram Protocol)"></a>UDP(User Datagram Protocol)</h2><p>使用原因：无连接，无差错处理。不建立连接过程所以无延时。简单。数据段比较简单。<br>无连接：发送方和接收方没有握手协议，每个数据段彼此独立<br>多用于做流媒体中：出错容忍，速率有保障。（视屏 udp 传输可能局部画面会有丢失，但是 tcp 由于部分画面的丢失导致整体必须重新传输）</p>
<p>RIP：发送大量路由信息<br>DNS：快速的数据请求<br>SNMP：主播和多播<br>TFTP，DHCP</p>
<h3 id="UDP-数据段"><a href="#UDP-数据段" class="headerlink" title="UDP 数据段"></a>UDP 数据段</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631605018-2f3167da-ad9b-4966-83b2-456d7c618e86.png" alt="CF33119A-E0EB-4264-A8A5-1667A637EE52"><br>8 字节的首部</p>
<p>Udp 端口和 tcp 端口是彼此独立的</p>
<h2 id="NAT-and-PAT-技术"><a href="#NAT-and-PAT-技术" class="headerlink" title="NAT and PAT 技术"></a>NAT and PAT 技术</h2><p>NAT （Network Address Translation，网络地址转换）<br>NAT table 将 private 地址映射为 global 地址<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631604886-b61d109d-55e2-4684-9aa2-e83e4c56edef.png" alt="ACD1B55E-28CD-4FA9-A3B9-3073990CE7F2"><br>地址划分<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597631605045-c6cee33b-b8b0-413d-b10e-f4e8e4d35d54.jpeg" alt="-w527"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631605059-5cd3e60d-c616-4e58-b3d3-fc9af68ba5b9.png" alt="973B9BB4-0938-4B29-A3A7-FC5E667D6205"><br>缺点：只能一对一映射，地址资源紧张<br>PAT：<br>通讯单位不是主机，而是 socket<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597631605355-4f35b244-c8f8-4ff8-933a-fabd2a788e2e.png" alt="7AC358EE-DE94-423B-B4BE-3EEE55D641F3"></p>
<h3 id="使用-tcp-和-udp-的协议"><a href="#使用-tcp-和-udp-的协议" class="headerlink" title="使用 tcp 和 udp 的协议"></a>使用 tcp 和 udp 的协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597635598913-2e03ace0-9be3-4730-96e7-810d281a31bb.jpeg" alt="-w436"></p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 数据链路层</title>
    <url>/2020/08/29/wqvpbi/</url>
    <content><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>链路：将两个相邻节点连接起来。（node：host 或者 router）<br>中间介质是物理介质没有逻辑因此无法检验数据</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367958829-d4bf0121-3280-4629-9ddf-839697535617.jpeg" alt="-w197"></p>
<h3 id="一二层区别"><a href="#一二层区别" class="headerlink" title="一二层区别"></a>一二层区别</h3><ul>
<li>第一层不能和上一次进行交流。第二次可以通过<strong>llc</strong>交流</li>
<li>第一层不能决定哪些主机进行发送和接受数据，第二层可以通过<strong>mac 地址</strong></li>
<li>第一层不能识别主机</li>
<li>第一层不能组织 bit，第二层可以封装成帧</li>
</ul>
<h3 id="第二层服务"><a href="#第二层服务" class="headerlink" title="第二层服务"></a>第二层服务</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597367958981-b045692a-76b9-4196-9e6d-2f86a629fb41.png" alt="833AC227-5298-4CBE-9DB0-817CC6CED8A2"><br>第一个服务多用于 lan 内。</p>
<h3 id="局域网介质访问控制标准（media-access-control）"><a href="#局域网介质访问控制标准（media-access-control）" class="headerlink" title="局域网介质访问控制标准（media access control）"></a>局域网介质访问控制标准（media access control）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367959062-1e727df2-272e-41d5-90af-9dc4e6d6dbd2.jpeg" alt="-w620"></p>
<p>介质访问两类：</p>
<h4 id="Deterministic-mac-protocols"><a href="#Deterministic-mac-protocols" class="headerlink" title="Deterministic mac protocols"></a>Deterministic mac protocols</h4><p>taking turns 有顺序<br>一个令牌在环路上循环，一个主机接受到令牌后可以传输数据，否则令牌循环一圈后被丢弃<br>Token Ring and FDDI</p>
<h4 id="Non-deterministic"><a href="#Non-deterministic" class="headerlink" title="Non-deterministic"></a>Non-deterministic</h4><p>Carrier Sense Multiple Access with Collision Detection (CSMA/CD)<br>会产生冲突的风险<br>(probabilistic)—first come,first serve<br>ethernet/802.3</p>
<h3 id="局域网通讯"><a href="#局域网通讯" class="headerlink" title="局域网通讯"></a>局域网通讯</h3><p>unicast 单播–a single packet is sent from the source to a single destination on a network<br>multicast 主播–consists of a single data packet that is sent to a specific subset of nodes on the network.<br>broadcast 广播–consists of a single data packet that is transmitted to all nodes on the network.</p>
<h2 id="Ethernet-and-csma-cd"><a href="#Ethernet-and-csma-cd" class="headerlink" title="Ethernet and csma/cd"></a>Ethernet and csma/cd</h2><h3 id="局域网标准"><a href="#局域网标准" class="headerlink" title="局域网标准"></a>局域网标准</h3><p>定义了物理介质和用来连接设备到介质的 connetcors<br>定义了设备和数据链路层连接的方法<br>数据链路层定义了数据如何通过物理介质传输，也定义了如何封装 protocol-specific traffic<br>数据链路层分为两部分 MAC（和介质相连接），LLC（和网络层相连接）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597367959115-f32efdbd-7e5a-4ef9-b456-b15b73f78a77.png" alt="DEE1E14D-6E13-402A-B917-AFDE3AF49581"></p>
<h4 id="mac-子层"><a href="#mac-子层" class="headerlink" title="mac 子层"></a>mac 子层</h4><p>帧结构规范（以字节为单位）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597367958941-d801960c-a874-47b5-b7f5-6fb37961b95e.png" alt="20D575F7-3059-4F70-9221-46725BB0E81E"></p>
<p>前导码：提示接受站帧的到来。（以 1010101011 开头否则是 1010101010）<br>目的地址：目的地址在前方便某些设备直接处理。三种 unicast（物理地址）, multicast（逻辑地址）, or broadcast（逻辑地址）.<br>源地址：mac 地址<br>长度：data 长度（46 ～ 1500bytes）<br>FCS：包含了循环冗余检验</p>
<h4 id="llc-子层"><a href="#llc-子层" class="headerlink" title="llc 子层"></a>llc 子层</h4><p>封装：将 packet（网络层数据）添加一些控制信息来帮助到达对应目的地<br>定义了 DSAP，SSAP 两个协议</p>
<h3 id="介质控制访问"><a href="#介质控制访问" class="headerlink" title="介质控制访问"></a>介质控制访问</h3><p>网卡上固定：mac 地址 48bits 十六进制为 12 位。分为两部分 OUI+VA<br>OUI：第一位 0 表示单播，1 表示主播/多播，第二位 0 表示全球唯一，1 表示本地唯一<br>如：（ 00-00-0c-12-34-56）<br>广播地址：全为 1（FFFFFFFFFFFF）。但是广播是通过打断站点，非目的主机会接受因此会消耗系统资源。<br>使用情景： 目的地址的 mac 地址不知道时；目的是所有主机</p>
<h4 id="以太网操作原理"><a href="#以太网操作原理" class="headerlink" title="以太网操作原理"></a>以太网操作原理</h4><p>总线拓扑：以太网将帧进行广播。每个站点会检查自身地址与目的地址<br>解决冲突：侦听链路是否空闲；广播全 1 的电信号（出现冲突）；回退时间（回退算法，帧至少 64 个字节必须占满链路）</p>
<h3 id="CSMA-CD-载波侦听多路访问-冲突检测"><a href="#CSMA-CD-载波侦听多路访问-冲突检测" class="headerlink" title="CSMA/CD 载波侦听多路访问/冲突检测"></a>CSMA/CD 载波侦听多路访问/冲突检测</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367959055-36a1708f-26a6-46a8-b629-900fd410e83b.jpeg" alt="-w677"></p>
<h2 id="wireless-lan-和-CSMA-CA"><a href="#wireless-lan-和-CSMA-CA" class="headerlink" title="wireless lan 和 CSMA/CA"></a>wireless lan 和 CSMA/CA</h2><h3 id="无线-lan"><a href="#无线-lan" class="headerlink" title="无线 lan"></a>无线 lan</h3><p>分为有无基础设施<br>Communications based on cells（有<br>The signals sent by a station can only be received by the stations nearby<br>Short-distance transmission</p>
<h4 id="wlan-标准"><a href="#wlan-标准" class="headerlink" title="wlan 标准"></a>wlan 标准</h4><p>IEEE 802.11 以基站为中心节点，也称作 wifi<br>IEEE 802.11b 高速直连方案<br>IEEE 802.11g<br>IEEE 802.11n</p>
<h4 id="WLAN-拓扑"><a href="#WLAN-拓扑" class="headerlink" title="WLAN 拓扑"></a>WLAN 拓扑</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367959116-a68154af-f9a9-4122-ada6-aa234ef4450c.jpeg" alt="-w649"><br>BSS（basic service set）一个基站（BS）和几个无线主机<br>在本地 BSS 所有主机可以和其他主机直接通信<br>AP（access point）和 BS 相同。连接在有线 lan 上提供网络接入服务。一个 AP 建立后会有一个 SSID 和频道被确定。<br>A BSS can connect to another BSS via a Distribution System(DS),<br>and constructs an Extended Service Set (ESS)<br>扫描：找到一个网络并加入<br>active scanning：<br>形成一个探针（probe）请求发送给无线节点，探针请求包含了<strong>SSID</strong>（service set identifier），当一个有相同 ssid 的 ap 被发现，ap 会产生一个探针回应。认真和连接建立<br>passive scanning：<br>现在大部分移动电子产品都是采用被动扫描（passive scanning）的方式，原因是扫描过程中不需要传送任何信号，可以省电。在被动扫描中，工作站会在信道列表（channel list）所列的各个信道之间不断切换，并静候 Beacon 帧的到来。所收到的任何帧都会被暂存起来，以便取出传送这些帧的 BSS 的相关数据</p>
<h3 id="WLAN-里的帧"><a href="#WLAN-里的帧" class="headerlink" title="WLAN 里的帧"></a>WLAN 里的帧</h3><p>三种：控制帧，管理帧，数据帧<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597367958957-6b7ee3a2-9b56-46d5-9102-fa6f49204ca4.png" alt="3924480A-D2C7-4B50-B051-7931C10E6631"><br>数据帧<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597367958931-c1bd8d27-8463-4291-a203-f8ad7fd2d0ac.png" alt="F015A9CE-7E05-43E1-A9FC-85364A8F2B33"></p>
<h3 id="CSMA-CA-波侦听多路访问／冲突避免"><a href="#CSMA-CA-波侦听多路访问／冲突避免" class="headerlink" title="CSMA/CA 波侦听多路访问／冲突避免"></a>CSMA/CA 波侦听多路访问／冲突避免</h3><p>Carrier Sense Multiple Access with Collision<br>Avoidance<br>1、监听到信道空闲时，并不是立即发送，而是等待一段时间再发送数据。<br>2、先发送一个很小的信道侦测帧 RTS（Request To Send），如果收到最近的接入点返回的 CTS（Clear To Send），就认为信道是空闲的，然后再发送数据</p>
<ol>
<li>若 RTS 或 CTS 发生冲突，采用二进制指数后退算法等待随机时间，重新开始<br>流程：<br>1、 首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。<br>2、 接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧 ACK（acknowledgment）应答。<br>3、 发送端收到 ACK 帧，确定数据正确传输，在经历一段时间间隔后，再发送数据<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367959093-85cdf7f7-2cad-4f79-9efa-bd23f984b9f9.jpeg" alt="-w649"></li>
</ol>
<p>（DIFS(Distributed Inter-frame Spacing,DIFS)分布式帧间间隙，在 CSMA/CA 中，媒体空闲，站点就在等待一个设定的时间即 DIFS。）</p>
<h4 id="CSMA-CD-与-CSMA-CA-两者区别"><a href="#CSMA-CD-与-CSMA-CA-两者区别" class="headerlink" title="CSMA/CD 与 CSMA/CA 两者区别"></a>CSMA/CD 与 CSMA/CA 两者区别</h4><p>1、 CSMA/CD 主要着眼点在冲突的侦测，当侦测到冲突时，进行相应的处理，要求设备能一边侦测一边发送数据。<br>2、CSMA/CA 主要着眼点在冲突的避免，协议里也看到经常是等待一段时间再做动作，通过退避尽量去避免冲突，还有就是先发送一些特别小的信道侦测帧来测试信道是否有冲突。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>CSMA/CD 主要适用以太网。<br>CSMA/CA 主要适用无线局域网。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367959109-9325bd41-34f2-4f63-abd6-96ffc338d3a8.jpeg" alt="-w576"></p>
<h2 id="第二层设备"><a href="#第二层设备" class="headerlink" title="第二层设备"></a>第二层设备</h2><h3 id="NIC-网卡"><a href="#NIC-网卡" class="headerlink" title="NIC 网卡"></a>NIC 网卡</h3><p>MAC 地址的长度为 48 位(6 个字节)，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个 MAC 地址，其中前 6 位 16 进制数 00-16-EA 代表网络硬件制造商的编号，它由 IEEE(电气与电子工程师协会)分配，而后 6 位 16 进制数 AE-3C-40 代表该制造商所制造的某个网络产品(如网卡)的系列号。<br>主要功能：</p>
<ol>
<li>LLC：与上层交流，告知当前网络信息（与主机 TCP/IP 站交互）</li>
<li>MAC：提供结构化</li>
<li>提供唯一的 mac 地址</li>
<li>把数据以帧的形式封装</li>
<li>发出信号（第一层功能）</li>
</ol>
<h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>基于 mac 地址，做 traffic 分离。<br>通过划分冲突域来提高网络效率<br>会成为通信瓶颈</p>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><p>学习：收集数据帧<br>mactable：有生命周期<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597367958927-0f69c2ca-2630-489c-841a-f1c0cd6fce3d.jpeg" alt="-w326"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>帧交换<br>mactable 生存与维护（基于 STP 协议）<br>虚电路（virtual circuit）母线带宽高（子线十倍左右）<br>交换机基于硬件进行转发，网桥基于软件，因此前者更快<br>不受 CSMA/CD 影响<br>网桥或交换机问题：如果一个设备发送数据但不知道目的地，将会进行广播，可能会形成广播风暴，增加链路时间，降低 trafic，资源浪费。</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 网络层</title>
    <url>/2020/08/29/tob4un/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层主要功能：网络间移动数据，用 hierarchical(分级的）地址转换，向下屏蔽介质差异，与其他网络通信<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562615-78383b4f-469f-445a-847b-2fedb74e186f.png#align=left&display=inline&height=438&margin=%5Bobject%20Object%5D&originHeight=438&originWidth=986&status=done&style=none&width=986" alt=""></p>
<p>设备：路由器<br>互联网段或者不同网络<br>基于 IP 地址进行逻辑选择<br>最优路径选择（通过路由表）<br>进行包转化</p>
<h2 id="IP-地址和子网"><a href="#IP-地址和子网" class="headerlink" title="IP 地址和子网"></a>IP 地址和子网</h2><p>包/datagram（数据报）：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565599597-a621b8b4-1913-4c63-adeb-67d4221268e6.png#align=left&display=inline&height=836&margin=%5Bobject%20Object%5D&originHeight=836&originWidth=1378&status=done&style=none&width=1378" alt=""><br>首部长度最大值：60byte<br>版本：4bit 4（IPV4），6（IPV6）<br>首部长度：4bit，最大 60byte<br>服务类型：8bit，一般不用<br>总长度：16bit，65535bytes，不超过最大传送单元（MTU）<br>标识：16bit ，计数器。相同标识为同一层原始报文，可以进行合并<br>标志：3bit 最高位为 0，DF：是否允许分辨（0 表示可以分片）MF（0 最后的分片）<br>片位移：13bit，以 8byte 为一个便宜单位。<br>分片：独立形成首部<br>生存时间 TTl：8bit，数据包在网络中可通过的路由器数的最大值<br>协议：8bit，指出将数据部分交给哪一个进程<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562309-3c2bf889-603e-4107-950b-2f3d851bbadd.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&originHeight=322&originWidth=734&status=done&style=none&width=734" alt=""><br>首部地址校验和：16bit<br>源地址，目的地址：4bytes</p>
<h3 id="网络层地址"><a href="#网络层地址" class="headerlink" title="网络层地址"></a>网络层地址</h3><p>IP 地址分为：networkID 和 hostID<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562476-ff1c3ffe-a28a-4d5a-8bc3-41a6784d097f.png#align=left&display=inline&height=568&margin=%5Bobject%20Object%5D&originHeight=568&originWidth=1106&status=done&style=none&width=1106" alt=""><br>networkid 用来标识相同网段，区分网段设备<br>hostid，一个网段内特定设备</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562218-120a3bfc-e699-4c22-b4a2-309e41d74379.png#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=1002&status=done&style=none&width=1002" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565599625-28aace57-3fe9-4480-a4eb-49d6235e39fe.jpeg#align=left&display=inline&height=626&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1144&status=done&style=none&width=1144" alt=""><br>主机数：一个地址用于 networkkid（全 0），最后一个用于广播地址<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565562411-91509a8a-fe3f-49c2-9687-41be357f709f.jpeg#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=1154&status=done&style=none&width=1154" alt=""><br>如果两个设备判断是在同一个网段，则可以直接通信，不需要三层设备的转发<br>广播对本网段的所用设备进行通信<br>受限广播地址：255.255.255.255 不可跨路由器</p>
<h3 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h3><p>subnet 也是一个网段<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565562419-2a6666a9-f90d-4f76-b1f6-0260206a3275.jpeg#align=left&display=inline&height=420&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=1258&status=done&style=none&width=1258" alt=""><br>最少向 host 借两位<br>（如果借一位取 0 是 networkID，取 1 是广播地址）<br>副作用：全 0 和全 1 不可用</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>别名：extended network prefix<br>定义我们可以使用多少位来构建网络和主机地址<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562262-0e16afc8-331b-4c15-bebd-5a7430a10b05.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=204&originWidth=792&status=done&style=none&width=792" alt=""><br>（注意全 0 和全 1 不可用需要减 2）</p>
<h2 id="第三层设备"><a href="#第三层设备" class="headerlink" title="第三层设备"></a>第三层设备</h2><p>路由器<br>有多个端口，每个端口连接不同的网段（要占据对应网络地址）。端口之间的网段地址不能相同，否则会有歧义（不知道想哪一个端口转发）</p>
<h3 id="路径选择"><a href="#路径选择" class="headerlink" title="路径选择"></a>路径选择</h3><p>基于 IP 地址的逻辑规范<br>形成报文-》加目的 IP 地址-〉放入帧-》发布在总线上</p>
<h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p>静态地址分配：独立的设备有自己的 ip 地址<br>动态地址分配：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565562332-8c2df520-3720-43ee-a370-bbb018611722.png#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=132&originWidth=666&status=done&style=none&width=666" alt=""></p>
<h2 id="ARP-protocol"><a href="#ARP-protocol" class="headerlink" title="ARP protocol"></a>ARP protocol</h2><p>地址解析协议（Address Resolution Protocol），是根据 IP 地址获取物理地址的一个 TCP/IP 协议<br>ARP table/arp 缓存<br>如果 arptable 没有对应的 MAC 地址，发送 ARP 请求，发送广播（将 mac 地址设为全 1），某主机发现 ip 地址与帧内的 ip 地址相匹配，则发送 arpreply，对应主机将 mac 地址写入条目。<br>arp 请求是<strong>本地化</strong>的（本网段请求）<br>不在本网段：1.default gateway（默认网关）2.proxy arp（代理 arp）</p>
<h3 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h3><p>网关：通讯和服务。配置 ip 地址时一般要配置网关<br>默认网关：路由器端口的 IP 地址</p>
<h3 id="proxy-arp"><a href="#proxy-arp" class="headerlink" title="proxy arp"></a>proxy arp</h3><p>一般启动在路由器上<br>路由器收到后，将对应端口的 mac 地址返回，在另一个端口进行转发<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565562549-cc70dc25-d1d6-4f00-9952-68e1e6083494.jpeg#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=818&status=done&style=none&width=818" alt=""></p>
<h2 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h2><h3 id="面向连接的服务-Connection-oriented-network-services"><a href="#面向连接的服务-Connection-oriented-network-services" class="headerlink" title="面向连接的服务 Connection oriented network services"></a>面向连接的服务 Connection oriented network services</h3><p>建立会话连接（逻辑连接）后进行传输，实现可靠传输</p>
<h3 id="电路交换-Circuit-switched"><a href="#电路交换-Circuit-switched" class="headerlink" title="电路交换 Circuit switched"></a>电路交换 Circuit switched</h3><p>建立虚电路的关系，不做路径选择<br>更可靠。会使利用效率低</p>
<h3 id="无连接网络服务-Connectionless-network-services"><a href="#无连接网络服务-Connectionless-network-services" class="headerlink" title="无连接网络服务 Connectionless network services"></a>无连接网络服务 Connectionless network services</h3><p>对突发传输有效<br>报文可能会丢失</p>
<h3 id="报文交换-Packet-switched"><a href="#报文交换-Packet-switched" class="headerlink" title="报文交换 Packet switched"></a>报文交换 Packet switched</h3><p>原始的报文分为子报文，自行发送（不一定在同一路径）<br>第三次服务是基于无连接和报文交换的</p>
<h2 id="路由和路由协议"><a href="#路由和路由协议" class="headerlink" title="路由和路由协议"></a>路由和路由协议</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565599606-7baf58dc-6893-485e-ab53-5d12b19e41db.jpeg#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&originHeight=600&originWidth=1422&status=done&style=none&width=1422" alt=""><br>在不同的路由器形成新的帧</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>IP 是网络层协议，跨网络路由协议</p>
<h3 id="路由表-routing-table"><a href="#路由表-routing-table" class="headerlink" title="路由表 routing table"></a>路由表 routing table</h3><p>非固定的，路由器启动后生成的</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>由网络管理员手动配置，不能自动修改<br>优点：可以隐藏部分路由，更安全<br>进行简单配置/默认路由</p>
<h4 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h4><p>根据不同的协议，进行学习不同信息来生成路由表。（RIP, IGRP, EIGRP, OSPF ）<br>优点：自动维护，适应网络变化</p>
<h3 id="routing-protocol-和-routed-protocol"><a href="#routing-protocol-和-routed-protocol" class="headerlink" title="routing protocol 和 routed protocol"></a>routing protocol 和 routed protocol</h3><p>前者是主动的操作，用于生成各种路由表的信息一般指动态路由表里的协议<br>后者是路由器之间，进行转发判断（IP，ipx）<br>关系:routing protocol determines how routed protocol is routed<br>routing protocols</p>
<ul>
<li>IGP：内部 Interior Gateway Protocols (RIP, IGRP, EIGRP,<br>OSPF) 自系统内部（逻辑划分）<ul>
<li>Distance-Vector Protocols (RIP, IGRP):邻居的视角（跳数）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565563129-c72dfb71-e07a-4af5-8e24-4b46243616f1.png#align=left&display=inline&height=736&margin=%5Bobject%20Object%5D&originHeight=736&originWidth=1278&status=done&style=none&width=1278" alt=""><br>时间代价。  （数字是跳数 hop）</li>
<li>Link State Protocols (OSPF):全局视角。shortest path<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597565563121-953a344e-764d-42f7-8a6f-6fc0117f2d0a.png#align=left&display=inline&height=740&margin=%5Bobject%20Object%5D&originHeight=740&originWidth=1238&status=done&style=none&width=1238" alt=""></li>
</ul>
</li>
<li>EGP：外部 Exterior Gateway Protocols (EGP, BGP)自系统之间<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597565562566-0bab7d67-dc74-4af0-a384-352a5c97e5b2.jpeg#align=left&display=inline&height=702&margin=%5Bobject%20Object%5D&originHeight=702&originWidth=1382&status=done&style=none&width=1382" alt=""></li>
</ul>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>Route Information Protocol 路由信息协议<br>评判标准仅基于跳数（hop）<br>最远可达跳数 15<br>每 30s 做一次广播<br>不会选择最快路径，选择跳数最少的路径<br>RIP v2 是主播，v1 用广播</p>
<h4 id="IGRP-EIGRP"><a href="#IGRP-EIGRP" class="headerlink" title="IGRP EIGRP"></a>IGRP EIGRP</h4><p>Interior Gateway Route Protocol。Enhanced IGRP<br>思科内部<br>评判标准：跳数，带宽，负载<br>跳数最远：255<br>每 90s 做一次更新</p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First.      开放式最短路径优先<br>评判依据：带宽<br>消耗更多的 cpu 和内存</p>
<h2 id="VLSM"><a href="#VLSM" class="headerlink" title="VLSM"></a>VLSM</h2><p>Variable-Length Subnet Masks<br>使用 VLSM 原因</p>
<blockquote>
<p>：1. 允许在同一个网络环境下使用更多的子网掩码 2.使用地址最大化 3.IPV4 到 IPV6 有效过渡<br>优点：有效利用 IP 地址；更好的路由聚合<br>支持 VLSM 的协议：（支持报文包含子网掩码）<br>Open Shortest Path First (OSPF)<br>Integrated Intermediate System to Intermediate System (Integrated IS-IS)<br>Enhanced Interior Gateway Routing Protocol(EIGRP)<br>RIP v2<br>Static routing.</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>先满足最大的子网</li>
<li></li>
</ol>
<h3 id="路由聚集（ROUTE-aggregation）"><a href="#路由聚集（ROUTE-aggregation）" class="headerlink" title="路由聚集（ROUTE aggregation）"></a>路由聚集（ROUTE aggregation）</h3><p>无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配 IP 地址以及在互联网上有效地路由 IP 数据包的对 IP 地址进行归类的方法<br>通过 cidr 和 vlsm 把小的路由合并变成大子网。<br>优点：减少路由表的条目；将拓扑变化进行隔离。</p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>因特网控制报文协议 Internet Control Message Protocol<br>为了提高数据报交付成功的机会<br>允许主机或路由器报告差错情况和提供有关异常情况的报告<br>属于 IP 层的协议，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，<br>组成 IP 数据报发送出去</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597585504118-32c7a5bd-b48f-4665-a9b1-5bf405cedb16.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&originHeight=650&originWidth=1252&status=done&style=none&width=1252" alt=""></p>
<h3 id="两种-ICMP-报文"><a href="#两种-ICMP-报文" class="headerlink" title="两种 ICMP 报文"></a>两种 ICMP 报文</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597585504239-3d9c73d0-86a0-4773-b1e8-aaea4ef28f5d.png#align=left&display=inline&height=810&margin=%5Bobject%20Object%5D&originHeight=810&originWidth=1194&status=done&style=none&width=1194" alt=""><br>目的站不可到达：<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597585504133-2d96eb60-07fa-4f94-8692-ed3882eeff79.jpeg#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=338&originWidth=682&status=done&style=none&width=682" alt=""></p>
<h4 id="差错报告报文的数据字段"><a href="#差错报告报文的数据字段" class="headerlink" title="差错报告报文的数据字段"></a>差错报告报文的数据字段</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597585504096-4990600d-1775-47c8-938d-327b0f002f7b.png#align=left&display=inline&height=410&margin=%5Bobject%20Object%5D&originHeight=410&originWidth=986&status=done&style=none&width=986" alt=""><br>不应发送 ICPM 差错报文的情况<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597585504099-a221dc8f-d4aa-4196-b7ee-40aaf06dfde6.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=892&status=done&style=none&width=892" alt=""></p>
<h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>是用 ICMP 的 echo request 和 echo reply 消息来实现/PING 使用 ICMP 回送请求与回送回答报文（两个报文）<br>ping 用来测试两个主机之间的连通性<br>PING 是应用层直接使用网络 IMCP 的例子，未经过 TCP 和 UDP</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>往年试卷总结</title>
    <url>/2020/08/29/esz5cg/</url>
    <content><![CDATA[<h2 id="2003-年"><a href="#2003-年" class="headerlink" title="2003 年"></a>2003 年</h2><p>函数参数是对象时，最好传入引用<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598070604057-522f4ec9-33e6-4573-a803-6ae25edaeaa2.png#align=left&display=inline&height=509&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1018&originWidth=1890&size=339868&status=done&style=none&width=945" alt="image.png"></p>
<h2 id="2013-年"><a href="#2013-年" class="headerlink" title="2013 年"></a>2013 年</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>C++中的空类：<br>声明时编译器不会产生任何函数，只会生成 1byte 的占位符<br>编译器只会在需要的时候生成 6 个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、一对取址运算符和一个 this 指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Empty();</span><br><span class="line">Empty(<span class="keyword">const</span> Empty&amp;);</span><br><span class="line">~Empty();</span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs);</span><br><span class="line">Empty* <span class="keyword">operator</span>&amp;();</span><br><span class="line"><span class="keyword">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>指针移动时最好重新声明一个局部变量<br>返回局部变量会造成调用的错误</p>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>赋值兼容原则；<br>将基类的指针赋值给派生类时，除非是虚函数，否则皆调用基类的函数。当函数为虚函数时，若参数有默认值则采用父类的默认值<br>构造和析构函数<br>1、子类对象在创建时会首先调用父类的构造函数<br>2、父类构造函数执行结束后，执行子类的构造函数<br>3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用<br>4、析构函数调用的先后顺序与构造函数相反<br>即 先构造父类，再构造成员变量、最后构造自己<br>     先析构自己，在析构成员变量、最后析构父类<br>                            //先构造的对象，后释放<br>参照：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Object()"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Object()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Object()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parent(<span class="keyword">const</span> <span class="keyword">char</span>* s) : Object(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Parent()"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Parent()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Child() : o2(<span class="string">"o2"</span>), o1(<span class="string">"o1"</span>), Parent(<span class="string">"Parameter from Child!"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Child()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Child()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Child child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"demo05_extend_construct_destory.cpp"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    run05();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object() Parameter from Child!</span><br><span class="line">Parent() Parameter from Child!</span><br><span class="line">Object() o1</span><br><span class="line">Object() o2</span><br><span class="line">Child()</span><br><span class="line">~Child()</span><br><span class="line">~Object()</span><br><span class="line">~Object()</span><br><span class="line">~Parent()</span><br><span class="line">~Object()</span><br></pre></td></tr></table></figure>

<p>同名：当子类成员变量与父类成员变量同名时，子类依然从父类继承同名成员<br>在子类中通过作用域分辨符::进行同名成员区分（<strong>在派生类中使用基类的同名成员，显式地使用类名限定符</strong>）<br>同名成员存储在内存中的不同位置<br>异常继承：<br>try catch 按顺序抛出异常，若基类异常在子类异常之前则抛出基类的异常</p>
<h2 id="2019-总结"><a href="#2019-总结" class="headerlink" title="2019 总结"></a>2019 总结</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i1 = <span class="number">1</span>, <span class="keyword">int</span> i2 =<span class="number">2</span>, <span class="keyword">int</span> i3 = <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数 f()</span></span><br><span class="line">f();             <span class="comment">//正确, i1=1, i2=2, i3=3</span></span><br><span class="line">f(<span class="number">3</span>);            <span class="comment">//正确, i1=3, i2=2, i3=3</span></span><br><span class="line">f(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">//正确, i1=2, i2=3, i3=3</span></span><br><span class="line">f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);      <span class="comment">//正确, i1=4, i2=5, i3=6</span></span><br><span class="line">f(, <span class="number">2</span>, <span class="number">3</span>);       <span class="comment">//错误, i1默认,其右边的i2和i3没有默认</span></span><br></pre></td></tr></table></figure>

<h3 id="模版与宏"><a href="#模版与宏" class="headerlink" title="模版与宏"></a>模版与宏</h3><p>1.宏是在预处理阶段处理，模板是在编译阶段处理 2.宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查。比如下面代码模板就会出错，而宏不会<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597652674755-e00ca635-3c27-4020-963a-1d5df105ed82.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=204&originWidth=201&size=0&status=done&style=none&width=201" alt=""> 3.宏直接就可以产生代码，而编译器遇到模板定义时，并不产生代码，只有当模板实例化后时才会产生代码。</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>指针的输出<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256791-c3453b5b-3369-4661-83af-c364a053ca2a.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=682&status=done&style=none&width=682" alt=""></p>
<p>取消常量属性<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597996641582-780e9713-6126-46af-857d-f14e852f01b8.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=1982&size=165666&status=done&style=none&width=991" alt="image.png"></p>
<p>不能间接改变常量<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597997163696-bbaa065e-71aa-478c-8a46-7d851e541398.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=968&size=43689&status=done&style=none&width=484" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>part 3</title>
    <url>/2020/08/29/c-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B3/</url>
    <content><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>同一论域中一个元素可有多种解释</li>
<li>提高语言灵活性</li>
<li>程序设计语言<ul>
<li>一名多用 ——函数重载</li>
<li>类属  ——template</li>
<li>OO 程序设计——虚函数</li>
</ul>
</li>
</ul>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>名同，参数不同；</p>
<p>静态绑定（调用函数是确定的）由 compiler/linker 决定</p>
<p>歧义控制：顺序，最佳匹配（每个实参的都不差，有一个实参匹配更好）</p>
<h4 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>参数至少包含一个用户自定义类型 (new、delete 除外）</p>
<ul>
<li>动机<ul>
<li>built_in 类型  compiler</li>
<li>自定义数据类型 程序员</li>
</ul>
</li>
<li>作用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span>      <span class="keyword">double</span> real, imag;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       Complex() &#123; real = <span class="number">0</span>; imag = <span class="number">0</span>; &#125;</span><br><span class="line">       Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123; real = r; imag = i; &#125;</span><br><span class="line"> 	   Complex <span class="keyword">operator</span> + (Complex&amp; x)&#123;</span><br><span class="line">         Complex temp;</span><br><span class="line">	     temp.real = real+x.real;</span><br><span class="line">	     temp.imag = imag+x.imag;</span><br><span class="line">	     <span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function">Complex <span class="title">add</span><span class="params">(Complex&amp; x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex   a(1,2),b(3,4), c;</span><br><span class="line">c = a.add(b);<span class="comment">//期望写成c=a+b</span></span><br><span class="line">c=a+b;<span class="comment">//c=a.operator +(b);类似于函数重载</span></span><br></pre></td></tr></table></figure>

<p>输出操作符重载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day &#123; SUN, MON, TUE, WED, THU, FRI, SAT&#125;;</span><br><span class="line">Day&amp; <span class="keyword">operator</span>++(Day&amp; d)</span><br><span class="line">&#123;  <span class="keyword">return</span> d= (d==SAT)? SUN: Day(d+<span class="number">1</span>); &#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; o, Day&amp; d)</span><br><span class="line">&#123;	<span class="keyword">switch</span> (d)</span><br><span class="line">	&#123;	<span class="keyword">case</span> SUN: o &lt;&lt; <span class="string">"SUN"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MON: o &lt;&lt; <span class="string">"MON"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TUE: o &lt;&lt; <span class="string">"TUE"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WED: o &lt;&lt; <span class="string">"WED"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> THU: o &lt;&lt; <span class="string">"THU"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FRI: o &lt;&lt; <span class="string">"FRI"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SAT: o &lt;&lt; <span class="string">"SAT"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//返回是ostream原因是要链式调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;      Day d=SAT;</span><br><span class="line">       ++d;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可重载的操作符 .（成员访问运算符）  .*（成员指针访问运算符） :: （域操作符）?:（条件运算符）</p>
<p>.、.*运算符不能重载是为了保证访问成员的功能不能被改变，域运算符合 sizeof 运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。</p>
<p>重载原则</p>
<ul>
<li>方式<ul>
<li>类成员函数</li>
<li>带有类参数的全局函数</li>
</ul>
</li>
<li>遵循原有语法</li>
</ul>
<p>单目/双目</p>
<p>优先级</p>
<p>结合性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      A(<span class="keyword">int</span> i):x(i)&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">void</span> (A::*p_f)() ;<span class="comment">//函数指针</span></span><br><span class="line"></span><br><span class="line">  p_f= &amp;A::f;</span><br><span class="line"> (a.*p_f)();</span><br></pre></td></tr></table></figure>

<h4 id="双目操作符重载"><a href="#双目操作符重载" class="headerlink" title="双目操作符重载"></a>双目操作符重载</h4><ol>
<li>类成员函数</li>
</ol>
<p>格式</p>
<p><ret type> operator_ _# (<arg>)</p>
<p><em>this</em>   隐含</p>
<p>使用</p>
<p>&lt; class name&gt; a, b;</p>
<p><em>a # b ;</em></p>
<p><em>a.operator#(b) ;</em></p>
<ol start="2">
<li>全局函数</li>
</ol>
<p>友元</p>
<p><em>friend _<ret type></em> operator_ <em>#</em> <em>(<arg>,<arg>)</em></p>
<p>格式</p>
<p><ret type> <em>operator</em> <em>#</em> <em>(<arg>,<arg>)</em></p>
<p>限制</p>
<p><em>=  ()  []</em> -&gt;不能作为全局函数重载</p>
<p>当类中没有定义赋值运算符重载成员函数时,当程序执行到某一赋值语句时，程序就会调用与赋值语句中右值类型匹配的构造函数，而把这右值当作此构造函数的实参。有重载赋值操作符时，执行赋值语句时，程序就只会去调用相应的赋值运算符重载函数</p>
<p>=：1、因为它认为类中并没有重载赋值运算符的成员函数，所以它根据 C++的规则，会去调用相应的构造函数。<br>2、但是在全局里，我们已经重载了参数类型为此类类型的赋值运算符函数，而这赋值语句刚好和这函数匹配上了，根据 C++的规则，也会去调用这函数。<br>其他的操作符同理。</p>
<ol start="3">
<li>全局函数作为补充</li>
</ol>
<p>obj+10 与 10+obj 成员函数不能同时支持（第一个参数是成员函数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span></span></span><br><span class="line"><span class="class">&#123;</span>     <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(<span class="keyword">int</span> i, CL&amp; a);</span><br><span class="line">      <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(CL&amp; a, <span class="keyword">int</span> i);</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>单目运算符最好重载为类成员函数</p>
<p>双面运算符最好重载为类友元函数</p>
<h4 id="永远不要重载-amp-amp"><a href="#永远不要重载-amp-amp" class="headerlink" title="永远不要重载&amp;&amp; ||"></a>永远不要重载&amp;&amp; ||</h4><p>短路现象</p>
<p><em>if ((p != 0) &amp;&amp; (strlen(p) &gt;10))</em></p>
<p>重载前，编译器判断 p!=0 如果 p==0，则不会检测后半部分</p>
<p>重载后，编译器会函数调用，不会有短路现象</p>
<h4 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h4><p>如：++</p>
<p>类函数：<ret type> operator #()</p>
<p>全局函数：<ret type> operator #(<arg>)<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598060645825-abc25c8a-deb2-4d7c-aea3-f69e54533954.png#align=left&display=inline&height=482&margin=%5Bobject%20Object%5D&name=image.png&originHeight=964&originWidth=1126&size=136601&status=done&style=none&width=563" alt="image.png"></p>
<h4 id="特殊操作符重载"><a href="#特殊操作符重载" class="headerlink" title="特殊操作符重载"></a>特殊操作符重载</h4><h5 id="重载-new"><a href="#重载-new" class="headerlink" title="重载 new"></a>重载 new</h5><p>定位 new</p>
<p>new 重载可以带其他参数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045311-057360f1-67cc-4e59-96b6-b9f38624150c.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=630&status=done&style=none&width=630" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(A)];</span><br><span class="line">A *a=<span class="keyword">new</span> (buf)A;<span class="comment">//A的对象分配到buf所指的地址空间上</span></span><br></pre></td></tr></table></figure>

<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045483-e1985ac2-4098-40c9-9f44-a7fea8239f68.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=803&status=done&style=none&width=803" alt=""></p>
<p>定义了 new 后需要定义对应的 delete</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol>
<li>源代码复用机制</li>
<li>参数化模板</li>
<li>多态一种形式</li>
</ol>
<h4 id="类属函数"><a href="#类属函数" class="headerlink" title="类属函数"></a>类属函数</h4><p>同一个函数对不同类型的数据完成相同的操作</p>
<ol>
<li>宏实现： #define max(a,b) ((a)&gt;(b)?(a):(b)).缺陷 只能实现简单的功能，没有类型检查</li>
<li>函数重载：缺陷需要定义的重载函数太多，定义不全</li>
<li>函数指针： void sort(void<em>,unsigned int ,unsigned int,int(*cmp)(void</em>,void*))缺陷 需要定义额外参数，大量指针运算，实现复杂，可读性差</li>
<li>函数模板：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045432-26b05e0f-9c84-4b20-b143-c29105b161b8.png#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=519&status=done&style=none&width=519" alt=""></li>
</ol>
<p>Template :C98 之前(与类 class 含义不同)</p>
<p>Template 本身不被编译进去</p>
<p>模板支持内置类型（int) 也支持自定义类型，此时需要重载操作符</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045622-cea53cdb-bb1c-4612-b518-30793d2b13af.png#align=left&display=inline&height=529&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=817&status=done&style=none&width=817" alt=""></p>
<p>显式实例化：调用的时候把尖括号里的东西显式的写出来</p>
<p>template<templateA></p>
<p>函数模板默认参数位置比较灵活（一般函数默认参数从右开始复制）</p>
<p>函数模板和函数重载配合使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"><span class="keyword">int</span>  x, y, z;</span><br><span class="line"><span class="keyword">double</span> l, m, n;</span><br><span class="line">z = <span class="built_in">max</span>(x,y);</span><br><span class="line">l = <span class="built_in">max</span>(m,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(x,m);<span class="comment">//?</span></span><br><span class="line"><span class="comment">//定义一个max重载函数,编译器会优先匹配重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类属类"><a href="#类属类" class="headerlink" title="类属类"></a>类属类</h4><p>类定义带有类型参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span>    T <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">     <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//需要再次声明<span class="title">T</span>是类型参数</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span> &lt;T&gt;:</span>:push(T x) &#123; …  &#125;<span class="comment">//某个类型会具体实例化的stack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Stack</span> &lt;T&gt;:</span>:pop() &#123; … &#125;</span><br><span class="line">……</span><br><span class="line">Stack &lt;<span class="keyword">int</span>&gt; st1; <span class="comment">//显式实例化</span></span><br><span class="line">Stack &lt;<span class="keyword">double</span>&gt; st2;</span><br></pre></td></tr></table></figure>

<p>每个方法前需要再次声明 T</p>
<p>返回时也要再次声明</p>
<p>显式实例化</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>常见的处理方法：</p>
<ul>
<li>函数参数（返回值。引用参数）</li>
<li>逐层返回</li>
</ul>
<h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598062832280-83b72563-76e4-4d45-aaef-e1f1e9487a40.png#align=left&display=inline&height=336&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=1290&size=99690&status=done&style=none&width=645" alt="image.png"><br>catch(…)捕获所有异常</p>
<h2 id="I-O-处理"><a href="#I-O-处理" class="headerlink" title="I/O 处理"></a>I/O 处理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045489-67b6ae81-9d99-4073-82e7-fb0f32810573.png#align=left&display=inline&height=335&margin=%5Bobject%20Object%5D&originHeight=335&originWidth=564&status=done&style=none&width=564" alt=""></p>
<p>I/O 流库的三类输入/输出操作</p>
<p>控制台 I/O</p>
<p>标准 I/O 设备</p>
<p>cin、cout、cerr、clog（cin 带缓冲，cerr 不带缓冲）</p>
<p>文件 I/O</p>
<p>字符串 I/O</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h1 id="c-的新特性"><a href="#c-的新特性" class="headerlink" title="c++的新特性"></a>c++的新特性</h1><p>R-value Reference and Move Constructor<br>Extern Templates<br>Constant Expressions<br>Lambda Function<br>Delegating Constructor<br>Uniform Initialization<br>nullptr</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>左值和右值的区分标准在于能否获取地址。<br>左值：存储地址，绑定非常量/常量的引用。<br>右值不可以绑定非常量。（许多右值是临时变量）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112224-3ee386fc-ee60-4098-926a-3ba10195db72.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=390&status=done&style=none&width=390" alt=""><br>右值引用 ：&amp;&amp;a</p>
<h2 id="外部模版"><a href="#外部模版" class="headerlink" title="外部模版"></a>外部模版</h2><p>多次实例化效率变低<br>避免多次实例化<br>extern template void func(int);</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>constexpr<br>允许表达式内含有用户定义的值<br>编译器会在确定的某一时刻确定该表达式的值<br>老版本：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112471-a9b5acb6-2863-4015-83d5-f9ea9b4296a1.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=1342&status=done&style=none&width=1342" alt=""></p>
<p>新版：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112499-3efaa4db-e6c5-45a8-bcb7-99af38447166.png#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1348&status=done&style=none&width=1348" alt=""><br>编译器会在编译时刻计算对应的值</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1598024112464-f80b036f-45fc-4f0c-b6e2-db59534dbb66.jpeg#align=left&display=inline&height=576&margin=%5Bobject%20Object%5D&originHeight=576&originWidth=1376&status=done&style=none&width=1376" alt=""><br>对应的对象会在编译时刻确定对应的值，相当于一组常量，不需要开辟新的内存空间<br>const：只是不能修改对应的值，但是会占用其他的空间资源</p>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>用来声明函数对象，并可以使用局部变量<br>sort(items.begin(), items.end(),<br>[](int a, int b) { return a &lt; b; } //Lambda Function<br>);</p>
<p>lambda 捕获<br>[]  Capture nothing<br>[&amp;] Capture any referenced variable by reference<br>[=] Capture any referenced variable by making a copy<br>[=, &amp;foo] Capture any referenced variable by making a copy, but capture variable foo by reference<br>[bar] Capture bar by making a copy; don’t copy anything else</p>
<h2 id="Delegating-Constructor-委托构造函数"><a href="#Delegating-Constructor-委托构造函数" class="headerlink" title="Delegating Constructor 委托构造函数"></a>Delegating Constructor 委托构造函数</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112605-6bab2243-d760-4fe2-b8f3-85f90e54fc6a.png#alt=04A81750-C068-419B-A26C-CFB40E8D08E2" alt=""></p>
<h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>接受初始化列表<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1598024112429-4d4fd778-8fa9-42d3-b69c-c5f165635880.jpeg#alt=-w410" alt=""></p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>空指针<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112407-26472d94-7887-45d8-b3b2-4c6c95603deb.png#alt=F687C51E-3DB0-42A9-82C3-5C79B95670DF" alt=""><br>之前的 NULL 一般是 0</p>
]]></content>
  </entry>
  <entry>
    <title>PART2 OOP</title>
    <url>/2020/08/29/hbxqf2/</url>
    <content><![CDATA[<h2 id="oo-十问"><a href="#oo-十问" class="headerlink" title="oo 十问"></a>oo 十问</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522561-b8a98a05-6e3c-471f-a45a-8e7f1468205c.png#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=775&status=done&style=none&width=775" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522541-f8f1bb96-4ea4-4d5d-9942-6eff8cae02d7.png#align=left&display=inline&height=420&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=679&status=done&style=none&width=679" alt=""></p>
<p>结构化——》命令的集合，可化为线性</p>
<p>oo：向对象发送消息</p>
<p>分类：Objected-Oriented</p>
<p>Object-Based (without Inheritance)</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>成员变量，成员函数<br>头文件和源文件<br>头文件：声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tdate</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">isLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> year,month,day;</span><br><span class="line">&#125;;<span class="comment">//头文件date.h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tdate::setDate</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Tdate加在函数名之前返回类型后面，说明是头文件类的方法</span></span><br><span class="line">    year=y;</span><br><span class="line">    month=m;</span><br><span class="line">    data=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tdate::isLeapYear</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="comment">//源文件date.cpp</span></span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//直接创建对象，并非引用。全局对象，创建在全局静态存储区域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     g.SetDate(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      TDate t;<span class="comment">//存储在栈区</span></span><br><span class="line">      t.SetDate(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">      TDate  *p = <span class="keyword">new</span> TDate;<span class="comment">//引用，heap</span></span><br><span class="line">      p-&gt;SetDate(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接在头文件实现类，那么编译器会将成员函数作为 inline 函数。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>对象的初始化，内存的分配。</p>
<p>与类同名，无返回类型；自动调用，不可以直接调用；可重载</p>
<p>默认构造函数，无参数。当类中未提供构造函数时，编译系统提供</p>
<p>当一个对象未完成初始化时，其内存是不确定，此时并不算完整的对象。因此，默认构造函数，主要任务是建立标识符，对其内存分配，而非成员变量的赋值。</p>
<p>： 单例，只能通过类内部进行创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">作用：保证一个<span class="class"><span class="keyword">class</span>只有一个实体（<span class="title">instance</span>），并为它提供一个全局唯一的访问点</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~singleton()&#123;<span class="comment">//析构时使用&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(_instance == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_instance = <span class="keyword">new</span> singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> _instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> singleton *_instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//最好将所有此类的实例化的进口全部堵死</span></span><br><span class="line">	singleton()</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	singleton(<span class="keyword">const</span> singleton&amp;)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton &amp;)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524736-30434b7f-0a56-48c9-b22c-a17e4cfae07b.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&originHeight=317&originWidth=627&status=done&style=none&width=627" alt=""></p>
<h3 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h3><p>构造函数的补充，减轻编译器负担</p>
<p>先于构造函数，按类数据成员申明次序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span>&amp;z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A():y(<span class="number">1</span>),z(x),x(<span class="number">0</span>)&#123;x=<span class="number">100</span>&#125;;<span class="comment">//顺序是先初始化x,y,z，x=100是赋值，不是初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522560-1d7137f7-5e97-4bba-9e36-22ba5ded106b.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&originHeight=156&originWidth=412&status=done&style=none&width=412" alt=""></p>
<p>初始化大小不是 x：size 未初始化（先初始化的 p）</p>
<p>成员初始化表作用：</p>
<p>与 Java 不同的是，成员变量除了常量类型外，不允许在类内部初始化（C98）</p>
<p>减轻编译器负担：如果用构造函数赋值，对象已经初始化一次，及赋值了两次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A()&#123;m=<span class="number">0</span>;&#125;</span><br><span class="line">    	A(<span class="keyword">int</span> m1)&#123;m=m1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    A a;<span class="comment">//成员对象</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	B()&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    	B(<span class="keyword">int</span> x1)&#123;x=x1;&#125;</span><br><span class="line">    	B(<span class="keyword">int</span> x1,<span class="keyword">int</span> m1):a(m1)&#123;x=x1;&#125;<span class="comment">//指定成员对象的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;        <span class="comment">//调用B::B()和A::A()</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">//调用B::B(int)和A::A()</span></span><br><span class="line">    <span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//调用B::B(int,int)和A::A(int)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524066-4f5bd7e8-0f9b-4e51-891d-a9b844c2c311.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=674&status=done&style=none&width=674" alt=""></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象消亡，系统自动调用，heap 上的对象需要手动调用</p>
<p>释放对象持有的非内存资源</p>
<p>可声明为 private：无法在 stack 上分配对象，只能在 heap 上，强制自主控制对象存储分配,也不能直接 delete，需用手动调用对象的消除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A():</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	～A();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;<span class="comment">//报错</span></span><br><span class="line">    A *p=<span class="keyword">new</span> A;<span class="comment">//只能在堆上分配对象（栈资源有限）</span></span><br><span class="line">    p-&gt;destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数，类中获取的额外资源（文件资源，网络资源等）释放</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>创建对象时，用一同类的对象对其初始化</p>
<p>自动调用</p>
<blockquote>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
</blockquote>
<p>public:A(const A&amp; a);(引用&amp;，否则变为递归)</p>
<p>默认拷贝构造函数：Ø 逐个成员初始化(member-wise initialization) Ø 对于对象成员，该定义是递归的</p>
<p>浅拷贝问题：悬挂指针（解决：重载拷贝构造函数和操作符=）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524066-4f5bd7e8-0f9b-4e51-891d-a9b844c2c311.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=674&status=done&style=none&width=674" alt=""></p>
<p>通常在深拷贝时，采用自定义拷贝构造函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525301-71ad3959-7990-4188-b92a-51afc3afc4e7.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=309&originWidth=339&status=done&style=none&width=339" alt=""></p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> S=generate();</span><br></pre></td></tr></table></figure>

<p>可声明成 private:编译器不能调用拷贝构造函数，防止对象按值传递（需按引用传递）</p>
<h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525352-8b4e118c-d920-4036-844a-17cc6e025798.png#align=left&display=inline&height=452&margin=%5Bobject%20Object%5D&originHeight=452&originWidth=730&status=done&style=none&width=730" alt=""></p>
<p>在 heap 中创建对象</p>
<p>引入 new,delete:正确引用 constructor/destructor</p>
<p>malloc 不调用构造函数</p>
<p>free 不调用析构函数</p>
<p>new 可重载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A();</span><br><span class="line">    	A();</span><br><span class="line">&#125;</span><br><span class="line">A *p,*q;</span><br><span class="line">p = <span class="keyword">new</span> A;</span><br><span class="line"> <span class="comment">//在程序的heap中申请一块大小为sizeof(A)的内存</span></span><br><span class="line"><span class="comment">//调用A的默认构造函数对该空间上的对象初始化</span></span><br><span class="line"><span class="comment">//返回创建的对象的地址并赋值给p malloc不会进行后两步</span></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用A的另一个构造函数 A::A(int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>  p;</span><br><span class="line"><span class="comment">//调用p所指向的对象的析构函数</span></span><br><span class="line"><span class="comment">//释放对象空间</span></span><br><span class="line"><span class="keyword">delete</span> q;</span><br></pre></td></tr></table></figure>

<p>对象创建：</p>
<p>type ptrName= new type;</p>
<p>type ptrName= new type（params);</p>
<p>对象删除：</p>
<p>delete 后设置指针为 NULL</p>
<p>delete intPtr;</p>
<p>inPtr=NULL;//否则该指针为悬挂指针，今后可能用</p>
<h4 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p=<span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"><span class="comment">//不能显示初始化，相应的类必须有默认构造函数，delete 中[]不能省</span></span><br></pre></td></tr></table></figure>

<h4 id="动态二维数组"><a href="#动态二维数组" class="headerlink" title="动态二维数组"></a>动态二维数组</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525296-fa4e4608-d1a8-4f84-b8d4-9f42b9dd1daf.png#align=left&display=inline&height=468&margin=%5Bobject%20Object%5D&originHeight=468&originWidth=853&status=done&style=none&width=853" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990528333-147a995c-747b-4261-bc48-975ae71b9975.png#align=left&display=inline&height=413&margin=%5Bobject%20Object%5D&originHeight=413&originWidth=567&status=done&style=none&width=567" alt=""></p>
<h3 id="const-成员"><a href="#const-成员" class="headerlink" title="const 成员"></a>const 成员</h3><p>初始化放在成员初始化表中，原因：常量只能在初始化时确定值，不能赋值</p>
<p>类中 const 成员，仅在类生存的生命周期内存在，特殊情况：static const 编译期内常量</p>
<p>const 成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span>  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	     A(<span class="keyword">int</span> c): x(c) &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const 成员函数，加上关键字 const（方法声明之后）</p>
<p>常对象只能调用常成员函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="built_in">cout</span> &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">a.f();<span class="comment">//error,不可更改常对象内容</span></span><br><span class="line">a.show();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 f()定义为 const，编译器会报错原因如下<br>类中函数默认参数有<em>const this；<br>void f(A</em> const this)<br>当 const 修饰时，void show(const A* const this);this 指向对象内容不可更改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> &amp; indirect_int;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     A():indirect_int(*<span class="keyword">new</span> <span class="keyword">int</span>)&#123; ... &#125;</span><br><span class="line">    ~A() &#123; <span class="keyword">delete</span> &amp;indirect_int; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; indirect_int++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可更改indirect_int</span></span><br></pre></td></tr></table></figure>

<p>可看出 const 是防止直接改变值。</p>
<p>mutable：允许直接改变值。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>同一个类不同对象共享变量：</p>
<ol>
<li>如果共享变量定义为全局变量，则缺乏数据保护</li>
<li>名污染。不同类访问共同的变量</li>
</ol>
<p>静态成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>   x,y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> shared;</span><br><span class="line">        .....</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">int</span> A::shared=<span class="number">0</span>;<span class="comment">//定义必须放在类的外部，放在实现文件，不放在头文件，且只能定义一次</span></span><br><span class="line">A a, b;</span><br></pre></td></tr></table></figure>

<p>静态成员函数：只能存取 静态成员函数，调用静态成员函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">	&#123;</span>    <span class="keyword">static</span> <span class="keyword">int</span> shared;</span><br><span class="line">	     <span class="keyword">int</span> x;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">	     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; …shared…&#125;</span><br><span class="line">	     <span class="function"><span class="keyword">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; …x…shared…&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524697-274823ec-ef23-4036-8239-7219cf86ce0c.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&originHeight=353&originWidth=436&status=done&style=none&width=436" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>	&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> obj_count;</span><br><span class="line">	        …</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	      A()  &#123;   obj_count++; &#125;</span><br><span class="line">	      ~A()  &#123;   obj_count--; &#125;</span><br><span class="line">	      static int get_num_of_obj() ；</span><br><span class="line">	         …</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>  A::obj_count=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>  <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br><span class="line"><span class="comment">//类对象计数</span></span><br></pre></td></tr></table></figure>

<p>example：</p>
<p>单件模式 singleton</p>
<p>构造函数为私有，用静态函数计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">protected</span>:<span class="comment">//外界不能创建</span></span><br><span class="line">		 singleton()&#123;&#125;</span><br><span class="line">		 singleton(<span class="keyword">const</span> singleton &amp;);</span><br><span class="line">	<span class="keyword">public</span>:<span class="comment">//static来创建</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;   <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>?</span><br><span class="line">				m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">static</span> singleton * m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">singleton * singleton ::m_instance= <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类外部不能访问该类的 private 成员。若通过该类的 public 方法会降低 private 成员的访问效率</p>
<p>友元可以访问该类的私有变量或者函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524440-4c2829cb-3775-449a-8a0e-068b7ac8bf29.png#align=left&display=inline&height=279&margin=%5Bobject%20Object%5D&originHeight=279&originWidth=626&status=done&style=none&width=626" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">C::f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元不具有传递性</p>
<p>使用友元的原则</p>
<ul>
<li>避免将 data member 放在公开接口中</li>
<li>努力让接口完满且最小化</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于目标代码复用</p>
<h3 id="单继承（考试重点）"><a href="#单继承（考试重点）" class="headerlink" title="单继承（考试重点）"></a>单继承（考试重点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span>       <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="keyword">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">set_ID</span><span class="params">(<span class="keyword">int</span> x)</span>  </span>&#123; id = x; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">SetNickName</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname,s);&#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         </span>&#123; <span class="built_in">cout</span> &lt;&lt; nickname &lt;&lt; “ : “ &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"> 		 <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; nickname &lt;&lt; “ : “ &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Undergraduated_Student</span> :</span> <span class="keyword">public</span> Student<span class="comment">//建议public继承</span></span><br><span class="line">&#123;       <span class="keyword">int</span> dept_no;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">set_ID</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;...&#125;<span class="comment">//id不可访问</span></span><br><span class="line">		 <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;dept_no&lt;&lt;<span class="string">":"</span>&lt;&lt;nickname&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         &#125;<span class="comment">//overwritten，对基类所有同名函数隐藏</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">   		Student::nickname;<span class="comment">//要声明作用域，否则是重新声明</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">setNickName</span><span class="params">()</span>:</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student u;</span><br><span class="line">u.showInfo(<span class="number">10</span>);<span class="comment">//error.不可访问。在Undergraduated_Student名空间进行匹配，匹配上showInfo时进行参数匹配。参数匹配不上，不再会去其他名空间匹配。可以using Student::showInfo</span></span><br></pre></td></tr></table></figure>

<p>在没有继承的情况下，protected 和 private 相同。有继承时，派生类可以访问基类的 protected 成员</p>
<p>派生类不能访问基类对象的 protected 成员(传入已创建好的基类对象）</p>
<p>派生类继承基类中的数据，但不可访问</p>
<p>如果不是公有继承则基类中的所有 public 成员将会变为 private</p>
<p>构造函数和析构函数，赋值操作符重载函数不可继承。</p>
<p>c++与 Java 不同的是，派生类中的函数是重写而不是覆盖。如果需要覆盖，需要指明该函数是 virtual。只要派生类中有同名函数，会对基类其他所有同名函数（参数可能不同）进行隐藏。</p>
<p>。即虚函数。虚函数代表的是多态，而重写是静态绑定</p>
<p>继承方式：private，基类中的成员只和基类访问说明符有关。派生类的用户（派生类的派生类）则与继承方式有关</p>
<h3 id="友元和-protected"><a href="#友元和-protected" class="headerlink" title="友元和 protected"></a>友元和 protected</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Base</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">protected</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> prot_mem;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; ;</span></span></span><br><span class="line"><span class="function"><span class="params">class Sneaky : <span class="keyword">public</span> Base &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">friend</span> <span class="keyword">void</span> clobber&#123;Sneaky&amp;)</span> </span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> clobber&#123;Base&amp;);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//正确：clobber 能访问Sneaky对象的private和protected成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误： clobber 不能访问Base的protected 成员</span></span><br></pre></td></tr></table></figure>

<p>原因是，派生类的友元只能访问派生类的基类保护成员，不能直接访问基类友元</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524402-eeeb8d10-53c8-4536-bfe2-526110668ec4.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=402&status=done&style=none&width=402" alt=""></p>
<p>成员对象初始化与声明顺序有关</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598017699970-6a043c4a-e925-4498-8096-dffcc238a728.png#align=left&display=inline&height=504&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1008&originWidth=1538&size=299830&status=done&style=none&width=769" alt="image.png"><br>B 的拷贝构造函数会默认初始化 A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A; <span class="comment">//继承A所有的构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="类型相容"><a href="#类型相容" class="headerlink" title="类型相容"></a>类型相容</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524694-4eb4860d-8c5b-453c-9f17-d9273e61e519.png#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&originHeight=176&originWidth=580&status=done&style=none&width=580" alt=""></p>
<p>派生类对象赋值给基类：对象切片 ↑（a 对应存储空间比 b 小，b 中自有属性会丢失）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524487-b4dc6879-2c99-404c-b71d-603f33184fb9.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=566&status=done&style=none&width=566" alt=""></p>
<p>传参数尽量传引用否则会产生对象切片（信息会丢失）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525380-c184975f-696a-4ad2-99e1-ddbb3c0e87cf.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=760&status=done&style=none&width=760" alt=""></p>
<p>func1，func2 A::f()只看形参的类型（静态绑定）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524693-3c7e9160-7cee-45d6-a41b-47b40b3fe191.png#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&originHeight=437&originWidth=439&status=done&style=none&width=439" alt=""></p>
<p>C++默认前期绑定，java 默认动态绑定</p>
<p>动态绑定：根据实际引用和指向对象的类型。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法重定义（override）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525389-271dc85b-f530-4d29-9fbe-502c076108a2.png#align=left&display=inline&height=419&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=711&status=done&style=none&width=711" alt=""></p>
<h4 id="后期绑定的实现"><a href="#后期绑定的实现" class="headerlink" title="后期绑定的实现"></a>后期绑定的实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>     <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    h();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;      <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       f();</span><br><span class="line">      h();</span><br><span class="line">&#125;;</span><br><span class="line">A a; B b;</span><br><span class="line">A *p;</span><br><span class="line">p=&amp;a;或者p=&amp;b;</span><br><span class="line">p-&gt;f();<span class="comment">//f的实现与对象内存绑定在一起</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990528391-f92e3af0-1c9b-4fa6-9d3e-e58c899d3c06.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=530&status=done&style=none&width=530" alt=""></p>
<p>(*_((char _)p-4))(p)//函数调用即 p-&gt;f()</p>
<p>虚函数表(vtable)索引表</p>
<p>效率低：</p>
<p>空间：多 1byte，以及虚函数表</p>
<p>时间：指针的寻址。多一次解引用</p>
<p>非虚函数调用虚函数&amp;虚函数调用非虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">public</span>:</span><br><span class="line">	    A() &#123; f();&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; f(); g(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b; <span class="comment">//先调用A的构造函数A::A(),A::f(),B::B() 建议不要在构造函数中调用虚函数</span></span><br><span class="line">A *p=&amp;b;</span><br><span class="line">p-&gt;f(); <span class="comment">// B::f()</span></span><br><span class="line">p-&gt;g(); <span class="comment">//A::g() g是静态绑定的，与p类型有关</span></span><br><span class="line">p-&gt;h();	<span class="comment">//A::h, B::f, A::g    h也称为非虚接口即调用虚函数也调用非虚函数，可以替换部分内容，对应着模板模式。全局函数可以做成非虚接口来实现多态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span> </span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span> </span>&#123; g(); &#125;<span class="comment">//f(B* const this)，this-&gt;g();</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;f(); <span class="comment">//都调用b的版本，虚函数调用非虚函数，对象是派生类的</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525365-a070081c-5a5a-4dad-baf9-04ca59dfd6a5.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=709&status=done&style=none&width=709" alt=""></p>
<p>int f2()override//错误，编译器不允许编译器的重定义</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>相当于 Java 里的接口</p>
<p>声明时，在函数原型后面加上=0；</p>
<p>往往只声明，不实现</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>至少包含一个纯虚函数</p>
<p>不能创建对象,为派生类提供框架，派生类提供抽象基类的所有成员函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class">&#123;</span>      …</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524775-e0fda813-8f9d-4043-b50f-64b0eb49b953.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=621&status=done&style=none&width=621" alt=""></p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525364-12d2c664-1371-4d03-8c10-8cb6eabe29a8.png#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=663&status=done&style=none&width=663" alt=""></p>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><h4 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h4><p>只继承实现，不继承接口。（派生类不转化为基类</p>
<p>has-a 关系</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525442-2f6ae85b-5523-4b64-b62a-b7c53a9ff50e.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=814&status=done&style=none&width=814" alt=""></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>定义：</p>
<p><em>class</em> &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名 1&gt;，</p>
<p>[&lt;继承方式&gt;] &lt;基类名 2&gt;，…</p>
<p><em>{</em> 〈成员表〉<em>}</em></p>
<p>继承方式</p>
<p><em>public_、_private</em> 、<em>protected</em></p>
<p>继承方式及访问控制的规定同单继承</p>
<p>派生类拥有所有基类的所有成员</p>
<p>初始化顺序/基类的声明次序：</p>
<p>对基类构造函数/析构函数的调用次序</p>
<p>对基类数据成员的存储安排</p>
<p>名冲突：&lt;基类名&gt;::&lt;基类成员名&gt;</p>
<p>虚基类</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525369-da07800c-5372-4d55-9fda-7bed69dfba14.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&originHeight=303&originWidth=584&status=done&style=none&width=584" alt=""></p>
<p>#</p>
]]></content>
  </entry>
  <entry>
    <title>part 1 结构化编程</title>
    <url>/2020/08/29/sigxak/</url>
    <content><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ol>
<li>三要素：syntax（语法），semantic（语义），pragmatics（语用）</li>
<li>Backus–Naur Form：形式化语言描述程序语言<br>EBNF<br>::- _ _<br>A ::- a|b<br>D ::-0|1<br>定义无限集合 A::- aA|bA|A<br>A D 代表一个系列或者一个集合<br>判定：reduce/deduct</li>
<li>Avram Noam Chomsky   认为自然语言可以严格表示<br>G=（VN，VT，R，Z）<br>语言可以分成四类：RG，CFG，CSG，PSG<br>对应识别模型：FA(finite automata) ,PDA(pushdown),LBA (linear bounded),TM(turing machine)<br>对特例：ad hoc</li>
<li>语言的定义：特定的字母表上，按照语法，字符串组成的集合</li>
<li>语义;static dynamic<br>表示：操作语义、指称语义、公理语义</li>
</ol>
<h2 id="programming"><a href="#programming" class="headerlink" title="programming"></a>programming</h2><p>David Gries 认为科学对待编程——&gt;calculus { Q } S { R }<br>Donald Ervin Knuth 认为程序是艺术</p>
<h2 id="programming-paradigm-编程范式"><a href="#programming-paradigm-编程范式" class="headerlink" title="programming paradigm 编程范式"></a>programming paradigm 编程范式</h2><p>imperative programming：命令式</p>
<ol>
<li>过程</li>
<li>面向对象<br>declarative programming</li>
<li>functional：无副作用</li>
<li>logical<br>函数的副作用：改变环境的某些参数（函数调用与顺序有关）</li>
</ol>
<h2 id="c-的诞生"><a href="#c-的诞生" class="headerlink" title="c++的诞生"></a>c++的诞生</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597977929499-e3b5c9a4-6ce1-4cef-9f61-a10ac19cf2e7.png#align=left&display=inline&height=577&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1154&originWidth=1652&size=1508523&status=done&style=none&width=826" alt="image.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643348-b2536333-2e52-4879-a355-66bfe2152ad2.jpeg#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&originHeight=730&originWidth=1246&status=done&style=none&width=1246" alt=""><br>来源一：<br>fortran：科学的语言描述<br>algol60: 程序设计作为单独的学科<br>algol68:程序的标杆<br>这三者是对结构化编程的支持</p>
<p>来源二<br>BCPL/C：对系统软件的支持，可以直接触碰硬件，（不叫 D，叫 C++ 完全包含 c，并未淘汰 C 中不好的东西）</p>
<p>来源三：<br>simula67: class inherit 封装与继承。提到了虚函数（未从程序设计角度设计该语言 runtime 很慢，使用人较少）第一个有 OO 特征的语言</p>
<p>来源四：<br>CLu，Ada：源代码级别，更高层次的抽象<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643321-63aa84c9-12f9-41f3-823d-dd9948cf0795.jpeg#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=324&status=done&style=none&width=324" alt=""></p>
<p>C++诞生：</p>
<ol>
<li>1979:博士论文，simula 性能太差（linker 连接器出现问题），BCPLdebug 难。愿望：带有 simula 的 algol68 以 C 为基础实现。哲学观：实用主义，文学观：存在主义</li>
<li>带类的 C。工具：Cpre（预编译为 C）</li>
<li>linker 分别编译（编译一致性）类型安全</li>
<li>1983:用户 产业界+大学；运行环境： 硬件+OS。 cfront<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643402-60c4749c-bbde-4d66-a886-3d062bf419f9.jpeg#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&originHeight=976&originWidth=496&status=done&style=none&width=248" alt=""><br>预处理：编辑（edit）对 define 一些进行编辑。cpre：把 C++程序翻译成 c 程序给 Ccomlpier 发现语法错误，不懂 C 的语法。Cfront 懂 C 语法。</li>
</ol>
<p>区分初始化和赋值</p>
<p>c 和 c++ 的关系：超集。c 艹支持 c 所支持的全部编程技巧。任何 c 程序都能被 c 艹用基本相同的方法编写，并具备同等开销（时间、空间）</p>
<h2 id="结构化程序设计部分"><a href="#结构化程序设计部分" class="headerlink" title="结构化程序设计部分"></a>结构化程序设计部分</h2><p>地址：</p>
<table>
<thead>
<tr>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>global data   全程存在</td>
</tr>
<tr>
<td>stack   编译器决定 function 局部存在</td>
</tr>
<tr>
<td>heap   动态的，由程序员决定</td>
</tr>
</tbody></table>
<p>管理地址：指针</p>
<p>类型——》决定数据的行为</p>
<p>强/弱，静/动</p>
<p>c++属于强类型，动静结合。但允许程序员打破强类型</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>名、值、地址、类型、性质</p>
<p>处理：算数、逻辑、I/O</p>
<p>四种基本类型：int char float double(built-in)</p>
<p>typedef：为已有的类型取别名，</p>
<h2 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h2><p>data type</p>
<p>类型转换方式：coersion（隐式，casting（显式</p>
<p>求值次序：<em>d + x/y</em>d + ++y*。副作用：overflow</p>
<p>exception</p>
<p>操作符重载（多态）</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>表达式语句</p>
<p>IO 语句</p>
<p>控制流语句<br>framework</p>
<h3 id="switch-优化："><a href="#switch-优化：" class="headerlink" title="switch 优化："></a>switch 优化：</h3><p>用枚举类型 enum 代替字面常量</p>
<p>I18N</p>
<p><strong>表驱动</strong>：空间开销代替时间开销</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table>
<thead>
<tr>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
</tr>
<tr>
<td>stack</td>
</tr>
<tr>
<td>heap</td>
</tr>
</tbody></table>
<p>stack 与 data 区域区别：后者是全生命周期，前者利用代码的局部性，可以重复使用</p>
<p>是浮动的，生命周期是由编译器决定的</p>
<p>因为 stack 是重复使用，需要进行管理</p>
<p>heap：动态数据，生命周期是由程序员决定的。（free 归还）</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>定义不允许嵌套，先定义后使用</p>
<p>执行机制：建立被调用函数的占空间，参数传递，保存调用函数的运行状态，将控制转交给被调函数</p>
<p>stack 生长方向：高地址向低地址</p>
<p>ebp：栈底指针（当前函数）</p>
<p>esp：栈顶指针</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>值传递 value</p>
<p>cost：传输内容，指令地址（eip）栈顶和栈底 0</p>
<p>引用传递 reference</p>
<p>总结：</p>
<ol>
<li>push arguments</li>
<li>save context:save return address, save caller’s base pointer</li>
<li>execute function:set new base pointer,allocate space, carry out some tasks,release space</li>
<li>recover context</li>
<li>continue to execute caller function</li>
</ol>
<p>call by name :delayed evaluation</p>
<p>前提：函数无副作用。</p>
<p>call by value result</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>名同参数不同</p>
<p>c 不支持，c++支持</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>void f(int,int=2);</p>
<p>默认参数用在声明。默认参数顺序：右到左。</p>
<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><p>不产生函数调用，减少开销，增强可读性</p>
<p>实现方法：编译系统将为 inline 创建一段代码，在调用点，做替换。</p>
<p>不能实现递归</p>
<p><strong>适用</strong>：使用频率高，简单，小段代码。如构造函数</p>
<p><strong>限制：非递归</strong></p>
<p>仅是对编译器的建议，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<p><strong>定义</strong>在类中的<strong>成员函数</strong>默认都是<strong>内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上  <strong>inline</strong>，否则就认为不是内联的。</p>
<p>inline 是一种”<strong>用于实现的关键字</strong>“，而不是一种”用于声明的关键字”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125; <span class="comment">// inline 与函数定义体放在一起</span></span><br></pre></td></tr></table></figure>

<p>强行使用 inline 的缺点：</p>
<ol>
<li>增大目标代码（1000+20，inline：1000*20）</li>
<li>病态换页——抖动（trash）</li>
<li>降低指令 cache 的命中率</li>
</ol>
<p>被 cc 拒绝的类型：长且复杂如 loop，swtich/指针</p>
<h2 id="程序组织"><a href="#程序组织" class="headerlink" title="程序组织"></a>程序组织</h2><p>程序结构：逻辑结构，物理结构</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256777-ff68a974-a3de-414d-8fbe-83a3aa827b6c.png#align=left&display=inline&height=518&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=499&status=done&style=none&width=499" alt=""></p>
<p>lib 文件：obj 文件的组合<br>头文件：常量的定义，变量/函数声明，类型定义，内联函数，编译预处理</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>程序级(Code,data 全生命周期)，文件级（全生命周期），函数级(stack），块级（stack）。</p>
<p>引用外部文件：extern 修饰</p>
<p>协同——》头文件</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256792-8861b183-a1eb-44f2-8960-3bd00fbe3138.png#align=left&display=inline&height=471&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=686&status=done&style=none&width=686" alt=""></p>
<p>对外不可见：static：程序级——》文件级</p>
<p>特殊：静态局部变量仍然在 stack（全生命周期）。<br>main：全生命周期，但是又在 stack（在栈底部）</p>
<p>常量：默认文件级</p>
<p><strong>总结</strong>：接口放在头文件中，不想对外使用用 static 修饰，常量通常提出一个头文件（const.h)</p>
<p>头文件：常量定义、变量/函数声明、编一预处理、类型定义，<strong>内联函数</strong></p>
<p>inline 基于源代码的复用，即将其完整写入头文件。</p>
<p>（基于目标代码的复用，只需看到接口）</p>
<p>如果 inline 被拒绝后，cc 将其变为 static（局部于文件作用域），否则同一份代码存在不同文件，造成代码冗余</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>有限的作用域更加灵活的运用</p>
<p>理念</p>
<ol>
<li>兼容：防冲突；遇冲突，可选择，易扩展</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221259730-d3a2a910-8682-46fe-8ef4-94bbe516fc31.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=475&status=done&style=none&width=475" alt=""></p>
<ol start="2">
<li>快速</li>
</ol>
<p>两种形式：</p>
<p>declaration</p>
<p>directive</p>
<p>namespace 中的变量 和全局变量命名相同时会报错</p>
<h2 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h2><h3 id="编译预处理（不懂-c-语法）"><a href="#编译预处理（不懂-c-语法）" class="headerlink" title="编译预处理（不懂 c++语法）"></a>编译预处理（不懂 c++语法）</h3><p>潜伏于环境：保持 cpp 不变，改变源程序语义</p>
<p>穿透作用域</p>
<h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ol>
<li>include： compose source text</li>
<li>define：</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256692-921e2e82-5db9-4731-83d1-771c023fecc6.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&originHeight=299&originWidth=457&status=done&style=none&width=457" alt=""></p>
<p>只是替换，无类型检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(a,b) a*b</span></span><br><span class="line"><span class="keyword">int</span> x= mul(<span class="number">1</span>+<span class="number">2</span>,<span class="number">2</span>+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x;<span class="comment">//8 not 15</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>indef</li>
<li>pragma</li>
</ol>
<p><strong>预处理指令</strong></p>
<blockquote>
<ol>
<li>#空指令，无任何效果</li>
<li>#include 包含一个源代码文件</li>
<li>#define 定义宏</li>
<li>#undef 取消已定义的宏</li>
<li>#if 如果给定条件为真，则编译下面代码</li>
<li>#ifdef 如果宏已经定义，则编译下面代码</li>
<li>#ifndef 如果宏没有定义，则编译下面代码</li>
<li>#elif 如果前面的#if 给定条件不为真，当前条件为真，则编译下面代码</li>
<li>#endif 结束一个#if……#else 条件编译块</li>
<li>#error 停止编译并显示错误信息</li>
</ol>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>c++允许数组越界</p>
<p>函数接口：void f(int a[],int n);//元素的个数需要参数显示的给出，不能通过 sizeof 获得</p>
<p>对于 char a[]=”abc”;char b[]={‘a’,’b’,’c’}; 前者可以用 cout，后者不行（无’\0’)</p>
<p>多维数组：降维处理</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597992968319-edbd867b-dc1e-4edd-8206-4932d4c1fc66.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&name=image.png&originHeight=932&originWidth=1288&size=271228&status=done&style=none&width=644" alt="image.png"></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>char s1=”abc”;等同于{‘a’,‘b’,‘c,’\0‘}</p>
<p>char s2={‘a’,‘b’,‘c}</p>
<p>烫出现原因：0xCCCC。vs 默认填充，为了容易发现错误</p>
<h3 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h3><p>和 class 区别：class 默认私有，struct 默认公开</p>
<p>alignment：以提高访问效率</p>
<p>sizeof 不一定是数据大小之和，默认对齐大小为 4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    short c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(B);<span class="comment">//12</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>共享存储空间</p>
<p>不同名称分配同一地址</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256748-b4b7c8aa-e0c2-45f2-b7bc-be549ef1297b.png#align=left&display=inline&height=253&margin=%5Bobject%20Object%5D&originHeight=253&originWidth=378&status=done&style=none&width=378" alt=""></p>
<p>公共的属性要在公共的部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> c&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    short z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(c);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597995250098-a42e9602-2791-425b-93f9-10d3b0a56038.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=1326&size=114437&status=done&style=none&width=663" alt="image.png"><br>FIGURE_TYPE 用于判断图形类别相当于标识</p>
<p>添加其他属性<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597995326962-954b78d3-ab91-465d-a6e1-eeb6c44bf2cf.png#align=left&display=inline&height=525&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1050&originWidth=1604&size=186089&status=done&style=none&width=802" alt="image.png"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>主要作用：管理地址信息。管理数据，调用代码</p>
<h4 id="定义与基本操作"><a href="#定义与基本操作" class="headerlink" title="定义与基本操作"></a>定义与基本操作</h4><p>单纯的管理地址：void*可以做公共接口，任何操作必须强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *p1=p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *q=p;</span><br><span class="line">*((<span class="keyword">int</span>*) q)</span><br></pre></td></tr></table></figure>

<p>p1 的赋值是错误的不安全。但是 q 可以，但是无法对地址对应的值进行直接操作</p>
<h6 id="pointer-literal"><a href="#pointer-literal" class="headerlink" title="pointer literal"></a>pointer literal</h6><p>nullptr：初始化不知道指针所指地址时，保证指针处于安全位置</p>
<p>c:#define NULL ((void*)0)</p>
<pre><code>可能造成问题：其他类型指针再次赋值void*，导致不同类型指针的赋值</code></pre><p>c++：#define NULL 0</p>
<pre><code>        int *p=NULL；

可能造成问题：函数重载如：func(int); func(char*);那么func(NULL)会调用第一个</code></pre><p>c++17:nullptr</p>
<p>加减数字：单位（sizeof（数据类型））</p>
<p>同类型相减：偏移量</p>
<p>输出：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256791-c3453b5b-3369-4661-83af-c364a053ca2a.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=682&status=done&style=none&width=682" alt=""></p>
<p>特例原因：cout 实现机制</p>
<p>ostream&amp;operator&lt;&lt;(osteam&amp;,char*)</p>
<h5 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h5><p>只能管理信息。除了赋值操作，必须做强制转换</p>
<p>例：将某块内存清零—&gt;把内存中的每一个 byte 设为 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span>*pointer,<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>*p=(<span class="keyword">char</span>*)pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">size</span>;k++)</span><br><span class="line">        *p++=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">100</span>]</span><br><span class="line"><span class="built_in">memset</span>(&amp;a,<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="built_in">memset</span>(&amp;B,<span class="keyword">sizeof</span>(B))</span><br></pre></td></tr></table></figure>

<h5 id="常量指针-const-TYPE-NAME"><a href="#常量指针-const-TYPE-NAME" class="headerlink" title="常量指针 const TYPE *NAME"></a>常量指针 const TYPE *NAME</h5><p>常量指针不可赋值 只读不写</p>
<p>const 变量只能用常量指针获取地址（不能间接改变常量）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256690-ebf8998d-a63f-4e28-a88a-3c3ec5557147.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=429&status=done&style=none&width=429" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*cp=<span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">*p=<span class="number">2</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">2</span>;</span><br><span class="line">cp=&amp;y;<span class="comment">//正确</span></span><br><span class="line">q=&amp;x;<span class="comment">//错误，不能间接地改变常量 q=const_cast&lt;int*&gt;(&amp;x)</span></span><br></pre></td></tr></table></figure>

<p>改变读写权限/保护变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>*p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//不可用</span></span><br></pre></td></tr></table></figure>

<p>const_cast&lt;int*&gt;取消常量属性</p>
<h5 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h5><p>只能在定义时初始化。<br>int*const p=&x;</p>
<p>不可移动的指针，但是可以管理内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p=&amp;x;</span><br><span class="line"></span><br><span class="line">p=&amp;y;<span class="comment">//错误，p不能移动；</span></span><br><span class="line">*p=<span class="number">1</span>;<span class="comment">//正确，可以改变内存的值,x会变</span></span><br></pre></td></tr></table></figure>

<p>const int*const p//初始化值和所指内容都不能改变</p>
<h5 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h5><p>&lt;&gt;()()</p>
<p>类型 （*函数名） （类型，类型，….)</p>
<p>函数指针和表驱动</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597998896529-520f1347-ac08-41a4-b418-62c158211726.png#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1278&originWidth=1698&size=269513&status=done&style=none&width=615" alt="image.png"></p>
<h5 id="指针与数组："><a href="#指针与数组：" class="headerlink" title="指针与数组："></a>指针与数组：</h5><p>数组名实际是地址（int*const)常量地址长度</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597999254696-4d455e67-ceda-4340-91e9-ddaab1a3dda4.png#align=left&display=inline&height=522&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1044&originWidth=1742&size=315545&status=done&style=none&width=871" alt="image.png"><br>指针数组：</p>
<p>char*s1[]={“c++”,”java”,”python”}（存的是引用）</p>
<p>char *s2[][8]={“c++”,”java”,”python”}(存的是字符）</p>
<p>main 函数：</p>
<p>int main(int agrc, char*<em>argv[],char</em> env[])</p>
<p>argc：参数个数</p>
<p>argv：命令行参数</p>
<p>env：环境参数</p>
<p>可变参数：</p>
<p>int printf(const char*,…)</p>
<h5 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h5><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597999940520-31b5e962-a193-4b67-af69-5cced1130d7c.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&name=image.png&originHeight=814&originWidth=1520&size=136785&status=done&style=none&width=760" alt="image.png"></p>
<h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><p>stack(生存规律可知)</p>
<p>heap 生命周期由程序决定</p>
<p>非编译时刻确定，存在 heap</p>
<h4 id="申请与归还"><a href="#申请与归还" class="headerlink" title="申请与归还"></a>申请与归还</h4><p>new&lt;类型&gt;</p>
<p>int  *p=new int;</p>
<p>int &amp;a=*p;(引用)</p>
<p>delete p;(归还)</p>
<p>或者是，</p>
<p>int<em>p=(int</em>) malloc(sizeof(int))</p>
<p>free(p);</p>
<p>申请一组：</p>
<p>new &lt;类型&gt;[整型数组]</p>
<p>int *p=new int[16]</p>
<p>int<em>p=(int</em>) malloc(sizeof(int)*16)</p>
<p>多维数组的申请</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> i5arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5arr *p=<span class="keyword">new</span> i5arr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*q)[<span class="number">5</span>]=(<span class="keyword">int</span>(*)[<span class="number">5</span>])p;</span><br></pre></td></tr></table></figure>

<p>由于申请内存可能申请不到，因此需要判断是否有效，做异常处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p!=null)</span><br><span class="line">    <span class="comment">//.....</span></span><br></pre></td></tr></table></figure>

<p>delete /delete[]：面向对象编程时，前者只会调用数组第一个的析构函数，后者会逐个调用每个对象的析构函数</p>
<p>free：只归还空间不调用析构函数</p>
<p>内存分配时，系统会自动创建一个 cookie，其包含了分配大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    *(p++)=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line"><span class="comment">//这样会导致系统free128个单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此,不能移动申请指针</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> *q=p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    *(q++)=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br></pre></td></tr></table></figure>

<h4 id="new-和-malloc-差别"><a href="#new-和-malloc-差别" class="headerlink" title="new 和 malloc 差别"></a>new 和 malloc 差别</h4><p>语法上 malloc 需要强制类型转换</p>
<p>语义上 面向对象编程时，new 会自动调用构造函数</p>
<h4 id="应用——链表"><a href="#应用——链表" class="headerlink" title="应用——链表"></a>应用——链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> content;</span><br><span class="line">    NODE*next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE*head=<span class="literal">NULL</span>:</span><br></pre></td></tr></table></figure>

<p>Insert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NODE*p=<span class="keyword">new</span> NODE;</span><br><span class="line">p-&gt;content=_value;</span><br><span class="line">p-&gt;next=null;</span><br><span class="line"><span class="comment">//头部插入</span></span><br><span class="line">p-&gt;next=head;</span><br><span class="line">head=p;</span><br><span class="line"><span class="comment">//尾部插入</span></span><br><span class="line">NODE*q=head;</span><br><span class="line"><span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">q-&gt;next=p;</span><br><span class="line"><span class="comment">//中间结点后插入</span></span><br><span class="line">NODE*q=head;</span><br><span class="line"><span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>&amp;&amp;q-&gt;content!=a)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    q-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>;</span><br><span class="line"><span class="comment">//中间结点前插入（双指针）</span></span><br><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;</span><br><span class="line"><span class="keyword">while</span> (q2 !=<span class="literal">NULL</span>  &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q2  != <span class="literal">NULL</span>) 	<span class="comment">//存在a</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>  (<span class="literal">NULL</span> == q1) 	<span class="comment">// a是第一个结点</span></span><br><span class="line">       &#123;   p-&gt;next = q2; head = p;   &#125;</span><br><span class="line">    <span class="keyword">else</span>  	<span class="comment">// a不是第一个结点</span></span><br><span class="line">      &#123;    p-&gt;next = q2;    q1-&gt;next = p;  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span>    <span class="comment">//不存在ai</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found!"</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256771-75c3ba7c-66ce-4c0e-9e2c-47f1626ee278.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=782&status=done&style=none&width=782" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>为一块已有的内存空间取别名</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221259627-7be42acf-3d37-47c2-bb0f-52ea9cac25e8.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=418&status=done&style=none&width=418" alt=""><br>不能返回局部变量</p>
<p>#</p>
]]></content>
  </entry>
  <entry>
    <title>2019-review</title>
    <url>/2020/08/29/uwigyz/</url>
    <content><![CDATA[<h1 id="review"><a href="#review" class="headerlink" title="review"></a>review</h1><h2 id="0-卷子"><a href="#0-卷子" class="headerlink" title="0. 卷子"></a>0. 卷子</h2><ol>
<li>PPT 范围外不考</li>
<li>review 中提到的是重点</li>
<li>3：3：3</li>
<li>：<ul>
<li>编程设计思想：小字、动画</li>
<li>不会考概念性的</li>
</ul>
</li>
<li>程序理解题：你就是编译器系列、电脑都比你强系列</li>
<li>代码分析：找问题，完形填空</li>
<li>设计：写一些代码</li>
<li>时间不够先记概念。</li>
</ol>
<h2 id="1-part-1"><a href="#1-part-1" class="headerlink" title="1. part_1"></a>1. part_1</h2><ol>
<li>to me：回去康康函数指针</li>
<li>C++那个关系图，一定要了解一下（10 分）<ul>
<li>简答</li>
</ul>
</li>
<li>宏：</li>
</ol>
<ul>
<li>头文件中的作用</li>
<li>如何定义和 assert debug 相关</li>
<li>宏和 C++新技术的不同</li>
<li>可以被 consts，enums，inlines 替代<ul>
<li>区别</li>
</ul>
</li>
</ul>
<ol start="3">
<li>const：</li>
</ol>
<ul>
<li>static const：赋值放在 cpp 之外并不允许二次出现 static<ul>
<li>定义在类外</li>
<li>不许二次定义</li>
<li>要当变量用得再声明</li>
<li>新标准可以放在声明时候赋值，但是此时是一个常量，为了取地址要二次声明。但是这个时候不许赋值了？？？？？？？？？？？？？？？？？？？？？？？</li>
</ul>
</li>
<li>能 const 就 const</li>
<li>iterator：<ul>
<li>const T*  t：正确但不方便<ul>
<li>改进</li>
</ul>
</li>
<li>T* const  t：指针不能动，不太对</li>
</ul>
</li>
<li>return value：返回右值要 const 类型</li>
<li>下标操作符需要两个类型：是 const 函数和不是 const 函数</li>
</ul>
<ol start="4">
<li>控制流没啥好考的</li>
<li>操作符重载：写法、标准格式<ul>
<li>[]</li>
<li>二义性</li>
</ul>
</li>
<li>表达式：<ul>
<li>左值、右值</li>
<li>优先级</li>
<li>副作用：自增自减</li>
</ul>
</li>
<li>inline：内联函数<ul>
<li>推荐而非强制（你瞎用会被编译器忽略</li>
<li>内联的本质类似于替换（就和宏类似</li>
<li>函数指针不一定会内联<ul>
<li>指针要有地址，如果内联了可能没指向</li>
<li>看调用方式</li>
</ul>
</li>
</ul>
</li>
<li>编译模块<ul>
<li>什么时候需要头文件？<ul>
<li>C++按照编译单元进行编译。</li>
<li>在模块中的使用需要提前有 include 头文件</li>
<li>“.h”引入需要小心重新编译（引入的头文件有改变，所有依赖的都要改</li>
<li>不引入头文件：使用<strong>引用、指针</strong>只需要一个前项声明<ul>
<li>可以隔离模块</li>
</ul>
</li>
<li>结论：声明是肯定要有的，看你需不需要大小来决定要不要头文件</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li>静态变量使用时的声明方法</li>
<li>non-local non-class 的东西</li>
</ol>
<h2 id="2-part-2"><a href="#2-part-2" class="headerlink" title="2. part_2"></a>2. part_2</h2><ol>
<li>模板和异常用到的比较简单，不会考的很复杂</li>
<li>单例模式：<ul>
<li>确定非局部状态变量状态，把其变成类内的</li>
</ul>
</li>
<li>类的构造和析构</li>
<li>对象的初始化和对象的赋值</li>
<li>类的分配和释放函数的使用</li>
<li>对象的按值传递和按引用传递、按常量传递、按指针传递</li>
<li></li>
<li>隐式/显式类型转换<ul>
<li>隐式：兼容类型、构造函数<ul>
<li>explicit：防止隐式类型转换</li>
<li>引用和指针因为不进行构造，不会转化</li>
</ul>
</li>
</ul>
</li>
<li>编译器帮你生成的和需要自己写的</li>
<li>操作符重载</li>
</ol>
<ul>
<li>友元/内嵌<ul>
<li>内嵌在不同的标准实现不同</li>
<li>会一种就行</li>
<li>能认不用能写</li>
</ul>
</li>
</ul>
<ol start="11">
<li>模板、泛型</li>
<li>是否需要新类型？</li>
</ol>
<h2 id="3-eg"><a href="#3-eg" class="headerlink" title="3. eg"></a>3. eg</h2><ol>
<li>call by value/ref<ul>
<li>string 也是类，有 string 也要调用拷贝构造函数</li>
<li>想调虚函数最好传指针</li>
<li>按值传递会造成</li>
</ul>
</li>
<li>操作符重载：<ul>
<li>返回局部变量的引用或者指针有被销毁的风险</li>
<li>大多数情况返回局部变量</li>
<li>左值结果一般返回引用，可以继续使用（连着用</li>
<li>二义性</li>
</ul>
</li>
<li>初始化：<ul>
<li>一般都要自己做一遍</li>
<li>成员初始化表：const、类（成员对象，只要一次拷贝构造）<ul>
<li>内置类型放哪都行</li>
<li>成员对象不想拷贝构造的话，不传值就行</li>
</ul>
</li>
<li>构造顺序<ul>
<li>多继承、虚继承</li>
<li>成员对象顺序</li>
</ul>
</li>
</ul>
</li>
<li>构造函数：<ul>
<li>默认 or not</li>
<li>调用顺序</li>
<li>在构造函数里调虚函数相当于调自己的函数（没有纯虚函数表也没有对象</li>
</ul>
</li>
<li>拷贝构造：<ul>
<li>拷贝构造、拷贝赋值</li>
<li>自己的拷贝函数要完整：<ul>
<li>成员对象全调拷贝函数</li>
<li>指针数组要申请新空间</li>
<li>赋值和拷贝构造同时更新</li>
</ul>
</li>
<li>基类成员私有：子类拷贝构造在初始化值表（长得很像成员初始化表）里用<ul>
<li>同步更新拷贝赋值：直接调用父类函数</li>
</ul>
</li>
</ul>
</li>
<li>析构函数：有多态定义为虚函数<ul>
<li>标准库都没有虚析构函数，最好不要继承</li>
</ul>
</li>
<li>静态变量：<ul>
<li>对于和，成员变量必须通过构造函数的的方式初始化。例如：上述程序中的 r 和 d 变量的初始化。<br>对于，static 成员变量需要在类定义体外进行初始化与定义，因为 static 数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。例如：上述程序中的 c 变量的初始化。<br>对于，该类型成员可以直接在类中初始化，也可以在类中声明，在类定义体外进行定义。例如：上述程序中的 x 和 xx 变量。<br>对于，该类型也是可以在类中声明在类定义体外进行定义，或者直接在类中定义初始化。例如：上述程序中的 z 和 zz 变量。```c<br>#include <iostream></li>
</ul>
</li>
</ol>
<p>using namespace std;</p>
<p>class Test<br>{<br>public:<br>Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。<br>~Test(){}</p>
<pre><code>int y;      //普通变量成员
int &amp;r;     //引用成员变量
const int d;    //常量成员变量
static int c;   //静态成员变量
static const int x = 2.1;   //静态常量整型成员变量
static const int xx;        //静态常量整型成员变量声明
static const double z;  //静态常量非整型成员变量声明
static const float zz = 6.6;    //静态常量非整型成员变量</code></pre><p>};</p>
<p>const int Test::xx = 4; //静态常量整型成员变量定义<br>const double Test::z = 5.1; ////静态常量非整型成员变量定义<br>int Test::c = 2;</p>
<p>int main(void)<br>{<br>cout &lt;&lt; Test::x &lt;&lt; endl;</p>
<pre><code>return 0;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4. myPro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1. 操作符重载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 二进制运算符&#96;&#x3D;&#96;（赋值），&#96;[]&#96;（数组订阅），&#96;-&gt;&#96;（成员访问）以及n元&#96;()&#96;（函数调用）运算符必须始终实现为**成员函数**。</span><br><span class="line">2. 一般法则</span><br><span class="line">   - 如果它是一**元运算符**，请将其实现为**_成员*_函数。</span><br><span class="line">   - 如果二进制运算符将**两个操作数均等地**对待（使它们不变），则将该运算符实现**_为非成员*_函数。</span><br><span class="line">   - 如果二进制运算符**_不能*_平等地***对待其两个操作数（通常会更改其左操作数），则在必须访问该操作数的私有部分的情况下，使其成为其左操作数类型的**_成员*_函数可能会很有用。</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>往年试卷总结</title>
    <url>/2020/08/29/c-g%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B4/</url>
    <content><![CDATA[<h2 id="2003-年"><a href="#2003-年" class="headerlink" title="2003 年"></a>2003 年</h2><p>函数参数是对象时，最好传入引用<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598070604057-522f4ec9-33e6-4573-a803-6ae25edaeaa2.png#align=left&display=inline&height=509&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1018&originWidth=1890&size=339868&status=done&style=none&width=945" alt="image.png"></p>
<h2 id="2013-年"><a href="#2013-年" class="headerlink" title="2013 年"></a>2013 年</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>C++中的空类：<br>声明时编译器不会产生任何函数，只会生成 1byte 的占位符<br>编译器只会在需要的时候生成 6 个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、一对取址运算符和一个 this 指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Empty();</span><br><span class="line">Empty(<span class="keyword">const</span> Empty&amp;);</span><br><span class="line">~Empty();</span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs);</span><br><span class="line">Empty* <span class="keyword">operator</span>&amp;();</span><br><span class="line"><span class="keyword">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>指针移动时最好重新声明一个局部变量<br>返回局部变量会造成调用的错误</p>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>赋值兼容原则；<br>将基类的指针赋值给派生类时，除非是虚函数，否则皆调用基类的函数。当函数为虚函数时，若参数有默认值则采用父类的默认值<br>构造和析构函数<br>1、子类对象在创建时会首先调用父类的构造函数<br>2、父类构造函数执行结束后，执行子类的构造函数<br>3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用<br>4、析构函数调用的先后顺序与构造函数相反<br>即 先构造父类，再构造成员变量、最后构造自己<br>     先析构自己，在析构成员变量、最后析构父类<br>                            //先构造的对象，后释放<br>参照：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Object()"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Object()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Object()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parent(<span class="keyword">const</span> <span class="keyword">char</span>* s) : Object(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Parent()"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Parent()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Child() : o2(<span class="string">"o2"</span>), o1(<span class="string">"o1"</span>), Parent(<span class="string">"Parameter from Child!"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Child()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Child()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Child child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"demo05_extend_construct_destory.cpp"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    run05();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object() Parameter from Child!</span><br><span class="line">Parent() Parameter from Child!</span><br><span class="line">Object() o1</span><br><span class="line">Object() o2</span><br><span class="line">Child()</span><br><span class="line">~Child()</span><br><span class="line">~Object()</span><br><span class="line">~Object()</span><br><span class="line">~Parent()</span><br><span class="line">~Object()</span><br></pre></td></tr></table></figure>

<p>同名：当子类成员变量与父类成员变量同名时，子类依然从父类继承同名成员<br>在子类中通过作用域分辨符::进行同名成员区分（<strong>在派生类中使用基类的同名成员，显式地使用类名限定符</strong>）<br>同名成员存储在内存中的不同位置<br>异常继承：<br>try catch 按顺序抛出异常，若基类异常在子类异常之前则抛出基类的异常</p>
<h2 id="2019-总结"><a href="#2019-总结" class="headerlink" title="2019 总结"></a>2019 总结</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i1 = <span class="number">1</span>, <span class="keyword">int</span> i2 =<span class="number">2</span>, <span class="keyword">int</span> i3 = <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数 f()</span></span><br><span class="line">f();             <span class="comment">//正确, i1=1, i2=2, i3=3</span></span><br><span class="line">f(<span class="number">3</span>);            <span class="comment">//正确, i1=3, i2=2, i3=3</span></span><br><span class="line">f(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">//正确, i1=2, i2=3, i3=3</span></span><br><span class="line">f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);      <span class="comment">//正确, i1=4, i2=5, i3=6</span></span><br><span class="line">f(, <span class="number">2</span>, <span class="number">3</span>);       <span class="comment">//错误, i1默认,其右边的i2和i3没有默认</span></span><br></pre></td></tr></table></figure>

<h3 id="模版与宏"><a href="#模版与宏" class="headerlink" title="模版与宏"></a>模版与宏</h3><p>1.宏是在预处理阶段处理，模板是在编译阶段处理 2.宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查。比如下面代码模板就会出错，而宏不会<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597652674755-e00ca635-3c27-4020-963a-1d5df105ed82.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=204&originWidth=201&size=0&status=done&style=none&width=201" alt=""> 3.宏直接就可以产生代码，而编译器遇到模板定义时，并不产生代码，只有当模板实例化后时才会产生代码。</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>指针的输出<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256791-c3453b5b-3369-4661-83af-c364a053ca2a.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=682&status=done&style=none&width=682" alt=""></p>
<p>取消常量属性<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597996641582-780e9713-6126-46af-857d-f14e852f01b8.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=1982&size=165666&status=done&style=none&width=991" alt="image.png"></p>
<p>不能间接改变常量<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597997163696-bbaa065e-71aa-478c-8a46-7d851e541398.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=968&size=43689&status=done&style=none&width=484" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>part 3</title>
    <url>/2020/08/29/gmso4g/</url>
    <content><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>同一论域中一个元素可有多种解释</li>
<li>提高语言灵活性</li>
<li>程序设计语言<ul>
<li>一名多用 ——函数重载</li>
<li>类属  ——template</li>
<li>OO 程序设计——虚函数</li>
</ul>
</li>
</ul>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>名同，参数不同；</p>
<p>静态绑定（调用函数是确定的）由 compiler/linker 决定</p>
<p>歧义控制：顺序，最佳匹配（每个实参的都不差，有一个实参匹配更好）</p>
<h4 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>参数至少包含一个用户自定义类型 (new、delete 除外）</p>
<ul>
<li>动机<ul>
<li>built_in 类型  compiler</li>
<li>自定义数据类型 程序员</li>
</ul>
</li>
<li>作用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span>      <span class="keyword">double</span> real, imag;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       Complex() &#123; real = <span class="number">0</span>; imag = <span class="number">0</span>; &#125;</span><br><span class="line">       Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123; real = r; imag = i; &#125;</span><br><span class="line"> 	   Complex <span class="keyword">operator</span> + (Complex&amp; x)&#123;</span><br><span class="line">         Complex temp;</span><br><span class="line">	     temp.real = real+x.real;</span><br><span class="line">	     temp.imag = imag+x.imag;</span><br><span class="line">	     <span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function">Complex <span class="title">add</span><span class="params">(Complex&amp; x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex   a(1,2),b(3,4), c;</span><br><span class="line">c = a.add(b);<span class="comment">//期望写成c=a+b</span></span><br><span class="line">c=a+b;<span class="comment">//c=a.operator +(b);类似于函数重载</span></span><br></pre></td></tr></table></figure>

<p>输出操作符重载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day &#123; SUN, MON, TUE, WED, THU, FRI, SAT&#125;;</span><br><span class="line">Day&amp; <span class="keyword">operator</span>++(Day&amp; d)</span><br><span class="line">&#123;  <span class="keyword">return</span> d= (d==SAT)? SUN: Day(d+<span class="number">1</span>); &#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; o, Day&amp; d)</span><br><span class="line">&#123;	<span class="keyword">switch</span> (d)</span><br><span class="line">	&#123;	<span class="keyword">case</span> SUN: o &lt;&lt; <span class="string">"SUN"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MON: o &lt;&lt; <span class="string">"MON"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TUE: o &lt;&lt; <span class="string">"TUE"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WED: o &lt;&lt; <span class="string">"WED"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> THU: o &lt;&lt; <span class="string">"THU"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FRI: o &lt;&lt; <span class="string">"FRI"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SAT: o &lt;&lt; <span class="string">"SAT"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//返回是ostream原因是要链式调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;      Day d=SAT;</span><br><span class="line">       ++d;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可重载的操作符 .（成员访问运算符）  .*（成员指针访问运算符） :: （域操作符）?:（条件运算符）</p>
<p>.、.*运算符不能重载是为了保证访问成员的功能不能被改变，域运算符合 sizeof 运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。</p>
<p>重载原则</p>
<ul>
<li>方式<ul>
<li>类成员函数</li>
<li>带有类参数的全局函数</li>
</ul>
</li>
<li>遵循原有语法</li>
</ul>
<p>单目/双目</p>
<p>优先级</p>
<p>结合性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      A(<span class="keyword">int</span> i):x(i)&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">void</span> (A::*p_f)() ;<span class="comment">//函数指针</span></span><br><span class="line"></span><br><span class="line">  p_f= &amp;A::f;</span><br><span class="line"> (a.*p_f)();</span><br></pre></td></tr></table></figure>

<h4 id="双目操作符重载"><a href="#双目操作符重载" class="headerlink" title="双目操作符重载"></a>双目操作符重载</h4><ol>
<li>类成员函数</li>
</ol>
<p>格式</p>
<p><ret type> operator_ _# (<arg>)</p>
<p><em>this</em>   隐含</p>
<p>使用</p>
<p>&lt; class name&gt; a, b;</p>
<p><em>a # b ;</em></p>
<p><em>a.operator#(b) ;</em></p>
<ol start="2">
<li>全局函数</li>
</ol>
<p>友元</p>
<p><em>friend _<ret type></em> operator_ <em>#</em> <em>(<arg>,<arg>)</em></p>
<p>格式</p>
<p><ret type> <em>operator</em> <em>#</em> <em>(<arg>,<arg>)</em></p>
<p>限制</p>
<p><em>=  ()  []</em> -&gt;不能作为全局函数重载</p>
<p>当类中没有定义赋值运算符重载成员函数时,当程序执行到某一赋值语句时，程序就会调用与赋值语句中右值类型匹配的构造函数，而把这右值当作此构造函数的实参。有重载赋值操作符时，执行赋值语句时，程序就只会去调用相应的赋值运算符重载函数</p>
<p>=：1、因为它认为类中并没有重载赋值运算符的成员函数，所以它根据 C++的规则，会去调用相应的构造函数。<br>2、但是在全局里，我们已经重载了参数类型为此类类型的赋值运算符函数，而这赋值语句刚好和这函数匹配上了，根据 C++的规则，也会去调用这函数。<br>其他的操作符同理。</p>
<ol start="3">
<li>全局函数作为补充</li>
</ol>
<p>obj+10 与 10+obj 成员函数不能同时支持（第一个参数是成员函数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span></span></span><br><span class="line"><span class="class">&#123;</span>     <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(<span class="keyword">int</span> i, CL&amp; a);</span><br><span class="line">      <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(CL&amp; a, <span class="keyword">int</span> i);</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>单目运算符最好重载为类成员函数</p>
<p>双面运算符最好重载为类友元函数</p>
<h4 id="永远不要重载-amp-amp"><a href="#永远不要重载-amp-amp" class="headerlink" title="永远不要重载&amp;&amp; ||"></a>永远不要重载&amp;&amp; ||</h4><p>短路现象</p>
<p><em>if ((p != 0) &amp;&amp; (strlen(p) &gt;10))</em></p>
<p>重载前，编译器判断 p!=0 如果 p==0，则不会检测后半部分</p>
<p>重载后，编译器会函数调用，不会有短路现象</p>
<h4 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h4><p>如：++</p>
<p>类函数：<ret type> operator #()</p>
<p>全局函数：<ret type> operator #(<arg>)<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598060645825-abc25c8a-deb2-4d7c-aea3-f69e54533954.png#align=left&display=inline&height=482&margin=%5Bobject%20Object%5D&name=image.png&originHeight=964&originWidth=1126&size=136601&status=done&style=none&width=563" alt="image.png"></p>
<h4 id="特殊操作符重载"><a href="#特殊操作符重载" class="headerlink" title="特殊操作符重载"></a>特殊操作符重载</h4><h5 id="重载-new"><a href="#重载-new" class="headerlink" title="重载 new"></a>重载 new</h5><p>定位 new</p>
<p>new 重载可以带其他参数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045311-057360f1-67cc-4e59-96b6-b9f38624150c.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=630&status=done&style=none&width=630" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(A)];</span><br><span class="line">A *a=<span class="keyword">new</span> (buf)A;<span class="comment">//A的对象分配到buf所指的地址空间上</span></span><br></pre></td></tr></table></figure>

<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045483-e1985ac2-4098-40c9-9f44-a7fea8239f68.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=803&status=done&style=none&width=803" alt=""></p>
<p>定义了 new 后需要定义对应的 delete</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol>
<li>源代码复用机制</li>
<li>参数化模板</li>
<li>多态一种形式</li>
</ol>
<h4 id="类属函数"><a href="#类属函数" class="headerlink" title="类属函数"></a>类属函数</h4><p>同一个函数对不同类型的数据完成相同的操作</p>
<ol>
<li>宏实现： #define max(a,b) ((a)&gt;(b)?(a):(b)).缺陷 只能实现简单的功能，没有类型检查</li>
<li>函数重载：缺陷需要定义的重载函数太多，定义不全</li>
<li>函数指针： void sort(void<em>,unsigned int ,unsigned int,int(*cmp)(void</em>,void*))缺陷 需要定义额外参数，大量指针运算，实现复杂，可读性差</li>
<li>函数模板：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045432-26b05e0f-9c84-4b20-b143-c29105b161b8.png#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=519&status=done&style=none&width=519" alt=""></li>
</ol>
<p>Template :C98 之前(与类 class 含义不同)</p>
<p>Template 本身不被编译进去</p>
<p>模板支持内置类型（int) 也支持自定义类型，此时需要重载操作符</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045622-cea53cdb-bb1c-4612-b518-30793d2b13af.png#align=left&display=inline&height=529&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=817&status=done&style=none&width=817" alt=""></p>
<p>显式实例化：调用的时候把尖括号里的东西显式的写出来</p>
<p>template<templateA></p>
<p>函数模板默认参数位置比较灵活（一般函数默认参数从右开始复制）</p>
<p>函数模板和函数重载配合使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"><span class="keyword">int</span>  x, y, z;</span><br><span class="line"><span class="keyword">double</span> l, m, n;</span><br><span class="line">z = <span class="built_in">max</span>(x,y);</span><br><span class="line">l = <span class="built_in">max</span>(m,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(x,m);<span class="comment">//?</span></span><br><span class="line"><span class="comment">//定义一个max重载函数,编译器会优先匹配重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类属类"><a href="#类属类" class="headerlink" title="类属类"></a>类属类</h4><p>类定义带有类型参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span>    T <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">     <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//需要再次声明<span class="title">T</span>是类型参数</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span> &lt;T&gt;:</span>:push(T x) &#123; …  &#125;<span class="comment">//某个类型会具体实例化的stack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Stack</span> &lt;T&gt;:</span>:pop() &#123; … &#125;</span><br><span class="line">……</span><br><span class="line">Stack &lt;<span class="keyword">int</span>&gt; st1; <span class="comment">//显式实例化</span></span><br><span class="line">Stack &lt;<span class="keyword">double</span>&gt; st2;</span><br></pre></td></tr></table></figure>

<p>每个方法前需要再次声明 T</p>
<p>返回时也要再次声明</p>
<p>显式实例化</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>常见的处理方法：</p>
<ul>
<li>函数参数（返回值。引用参数）</li>
<li>逐层返回</li>
</ul>
<h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598062832280-83b72563-76e4-4d45-aaef-e1f1e9487a40.png#align=left&display=inline&height=336&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=1290&size=99690&status=done&style=none&width=645" alt="image.png"><br>catch(…)捕获所有异常</p>
<h2 id="I-O-处理"><a href="#I-O-处理" class="headerlink" title="I/O 处理"></a>I/O 处理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598021045489-67b6ae81-9d99-4073-82e7-fb0f32810573.png#align=left&display=inline&height=335&margin=%5Bobject%20Object%5D&originHeight=335&originWidth=564&status=done&style=none&width=564" alt=""></p>
<p>I/O 流库的三类输入/输出操作</p>
<p>控制台 I/O</p>
<p>标准 I/O 设备</p>
<p>cin、cout、cerr、clog（cin 带缓冲，cerr 不带缓冲）</p>
<p>文件 I/O</p>
<p>字符串 I/O</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h1 id="c-的新特性"><a href="#c-的新特性" class="headerlink" title="c++的新特性"></a>c++的新特性</h1><p>R-value Reference and Move Constructor<br>Extern Templates<br>Constant Expressions<br>Lambda Function<br>Delegating Constructor<br>Uniform Initialization<br>nullptr</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>左值和右值的区分标准在于能否获取地址。<br>左值：存储地址，绑定非常量/常量的引用。<br>右值不可以绑定非常量。（许多右值是临时变量）<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112224-3ee386fc-ee60-4098-926a-3ba10195db72.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=390&status=done&style=none&width=390" alt=""><br>右值引用 ：&amp;&amp;a</p>
<h2 id="外部模版"><a href="#外部模版" class="headerlink" title="外部模版"></a>外部模版</h2><p>多次实例化效率变低<br>避免多次实例化<br>extern template void func(int);</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>constexpr<br>允许表达式内含有用户定义的值<br>编译器会在确定的某一时刻确定该表达式的值<br>老版本：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112471-a9b5acb6-2863-4015-83d5-f9ea9b4296a1.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=1342&status=done&style=none&width=1342" alt=""></p>
<p>新版：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112499-3efaa4db-e6c5-45a8-bcb7-99af38447166.png#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1348&status=done&style=none&width=1348" alt=""><br>编译器会在编译时刻计算对应的值</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1598024112464-f80b036f-45fc-4f0c-b6e2-db59534dbb66.jpeg#align=left&display=inline&height=576&margin=%5Bobject%20Object%5D&originHeight=576&originWidth=1376&status=done&style=none&width=1376" alt=""><br>对应的对象会在编译时刻确定对应的值，相当于一组常量，不需要开辟新的内存空间<br>const：只是不能修改对应的值，但是会占用其他的空间资源</p>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>用来声明函数对象，并可以使用局部变量<br>sort(items.begin(), items.end(),<br>[](int a, int b) { return a &lt; b; } //Lambda Function<br>);</p>
<p>lambda 捕获<br>[]  Capture nothing<br>[&amp;] Capture any referenced variable by reference<br>[=] Capture any referenced variable by making a copy<br>[=, &amp;foo] Capture any referenced variable by making a copy, but capture variable foo by reference<br>[bar] Capture bar by making a copy; don’t copy anything else</p>
<h2 id="Delegating-Constructor-委托构造函数"><a href="#Delegating-Constructor-委托构造函数" class="headerlink" title="Delegating Constructor 委托构造函数"></a>Delegating Constructor 委托构造函数</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112605-6bab2243-d760-4fe2-b8f3-85f90e54fc6a.png#alt=04A81750-C068-419B-A26C-CFB40E8D08E2" alt=""></p>
<h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>接受初始化列表<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1598024112429-4d4fd778-8fa9-42d3-b69c-c5f165635880.jpeg#alt=-w410" alt=""></p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>空指针<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598024112407-26472d94-7887-45d8-b3b2-4c6c95603deb.png#alt=F687C51E-3DB0-42A9-82C3-5C79B95670DF" alt=""><br>之前的 NULL 一般是 0</p>
]]></content>
  </entry>
  <entry>
    <title>part 1 结构化编程</title>
    <url>/2020/08/29/ripes8/</url>
    <content><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ol>
<li>三要素：syntax（语法），semantic（语义），pragmatics（语用）</li>
<li>Backus–Naur Form：形式化语言描述程序语言<br>EBNF<br>::- _ _<br>A ::- a|b<br>D ::-0|1<br>定义无限集合 A::- aA|bA|A<br>A D 代表一个系列或者一个集合<br>判定：reduce/deduct</li>
<li>Avram Noam Chomsky   认为自然语言可以严格表示<br>G=（VN，VT，R，Z）<br>语言可以分成四类：RG，CFG，CSG，PSG<br>对应识别模型：FA(finite automata) ,PDA(pushdown),LBA (linear bounded),TM(turing machine)<br>对特例：ad hoc</li>
<li>语言的定义：特定的字母表上，按照语法，字符串组成的集合</li>
<li>语义;static dynamic<br>表示：操作语义、指称语义、公理语义</li>
</ol>
<h2 id="programming"><a href="#programming" class="headerlink" title="programming"></a>programming</h2><p>David Gries 认为科学对待编程——&gt;calculus { Q } S { R }<br>Donald Ervin Knuth 认为程序是艺术</p>
<h2 id="programming-paradigm-编程范式"><a href="#programming-paradigm-编程范式" class="headerlink" title="programming paradigm 编程范式"></a>programming paradigm 编程范式</h2><p>imperative programming：命令式</p>
<ol>
<li>过程</li>
<li>面向对象<br>declarative programming</li>
<li>functional：无副作用</li>
<li>logical<br>函数的副作用：改变环境的某些参数（函数调用与顺序有关）</li>
</ol>
<h2 id="c-的诞生"><a href="#c-的诞生" class="headerlink" title="c++的诞生"></a>c++的诞生</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597977929499-e3b5c9a4-6ce1-4cef-9f61-a10ac19cf2e7.png#align=left&display=inline&height=577&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1154&originWidth=1652&size=1508523&status=done&style=none&width=826" alt="image.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643348-b2536333-2e52-4879-a355-66bfe2152ad2.jpeg#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&originHeight=730&originWidth=1246&status=done&style=none&width=1246" alt=""><br>来源一：<br>fortran：科学的语言描述<br>algol60: 程序设计作为单独的学科<br>algol68:程序的标杆<br>这三者是对结构化编程的支持</p>
<p>来源二<br>BCPL/C：对系统软件的支持，可以直接触碰硬件，（不叫 D，叫 C++ 完全包含 c，并未淘汰 C 中不好的东西）</p>
<p>来源三：<br>simula67: class inherit 封装与继承。提到了虚函数（未从程序设计角度设计该语言 runtime 很慢，使用人较少）第一个有 OO 特征的语言</p>
<p>来源四：<br>CLu，Ada：源代码级别，更高层次的抽象<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643321-63aa84c9-12f9-41f3-823d-dd9948cf0795.jpeg#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=324&status=done&style=none&width=324" alt=""></p>
<p>C++诞生：</p>
<ol>
<li>1979:博士论文，simula 性能太差（linker 连接器出现问题），BCPLdebug 难。愿望：带有 simula 的 algol68 以 C 为基础实现。哲学观：实用主义，文学观：存在主义</li>
<li>带类的 C。工具：Cpre（预编译为 C）</li>
<li>linker 分别编译（编译一致性）类型安全</li>
<li>1983:用户 产业界+大学；运行环境： 硬件+OS。 cfront<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/392607/1597663643402-60c4749c-bbde-4d66-a886-3d062bf419f9.jpeg#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&originHeight=976&originWidth=496&status=done&style=none&width=248" alt=""><br>预处理：编辑（edit）对 define 一些进行编辑。cpre：把 C++程序翻译成 c 程序给 Ccomlpier 发现语法错误，不懂 C 的语法。Cfront 懂 C 语法。</li>
</ol>
<p>区分初始化和赋值</p>
<p>c 和 c++ 的关系：超集。c 艹支持 c 所支持的全部编程技巧。任何 c 程序都能被 c 艹用基本相同的方法编写，并具备同等开销（时间、空间）</p>
<h2 id="结构化程序设计部分"><a href="#结构化程序设计部分" class="headerlink" title="结构化程序设计部分"></a>结构化程序设计部分</h2><p>地址：</p>
<table>
<thead>
<tr>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>global data   全程存在</td>
</tr>
<tr>
<td>stack   编译器决定 function 局部存在</td>
</tr>
<tr>
<td>heap   动态的，由程序员决定</td>
</tr>
</tbody></table>
<p>管理地址：指针</p>
<p>类型——》决定数据的行为</p>
<p>强/弱，静/动</p>
<p>c++属于强类型，动静结合。但允许程序员打破强类型</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>名、值、地址、类型、性质</p>
<p>处理：算数、逻辑、I/O</p>
<p>四种基本类型：int char float double(built-in)</p>
<p>typedef：为已有的类型取别名，</p>
<h2 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h2><p>data type</p>
<p>类型转换方式：coersion（隐式，casting（显式</p>
<p>求值次序：<em>d + x/y</em>d + ++y*。副作用：overflow</p>
<p>exception</p>
<p>操作符重载（多态）</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>表达式语句</p>
<p>IO 语句</p>
<p>控制流语句<br>framework</p>
<h3 id="switch-优化："><a href="#switch-优化：" class="headerlink" title="switch 优化："></a>switch 优化：</h3><p>用枚举类型 enum 代替字面常量</p>
<p>I18N</p>
<p><strong>表驱动</strong>：空间开销代替时间开销</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table>
<thead>
<tr>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
</tr>
<tr>
<td>stack</td>
</tr>
<tr>
<td>heap</td>
</tr>
</tbody></table>
<p>stack 与 data 区域区别：后者是全生命周期，前者利用代码的局部性，可以重复使用</p>
<p>是浮动的，生命周期是由编译器决定的</p>
<p>因为 stack 是重复使用，需要进行管理</p>
<p>heap：动态数据，生命周期是由程序员决定的。（free 归还）</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>定义不允许嵌套，先定义后使用</p>
<p>执行机制：建立被调用函数的占空间，参数传递，保存调用函数的运行状态，将控制转交给被调函数</p>
<p>stack 生长方向：高地址向低地址</p>
<p>ebp：栈底指针（当前函数）</p>
<p>esp：栈顶指针</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>值传递 value</p>
<p>cost：传输内容，指令地址（eip）栈顶和栈底 0</p>
<p>引用传递 reference</p>
<p>总结：</p>
<ol>
<li>push arguments</li>
<li>save context:save return address, save caller’s base pointer</li>
<li>execute function:set new base pointer,allocate space, carry out some tasks,release space</li>
<li>recover context</li>
<li>continue to execute caller function</li>
</ol>
<p>call by name :delayed evaluation</p>
<p>前提：函数无副作用。</p>
<p>call by value result</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>名同参数不同</p>
<p>c 不支持，c++支持</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>void f(int,int=2);</p>
<p>默认参数用在声明。默认参数顺序：右到左。</p>
<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><p>不产生函数调用，减少开销，增强可读性</p>
<p>实现方法：编译系统将为 inline 创建一段代码，在调用点，做替换。</p>
<p>不能实现递归</p>
<p><strong>适用</strong>：使用频率高，简单，小段代码。如构造函数</p>
<p><strong>限制：非递归</strong></p>
<p>仅是对编译器的建议，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<p><strong>定义</strong>在类中的<strong>成员函数</strong>默认都是<strong>内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上  <strong>inline</strong>，否则就认为不是内联的。</p>
<p>inline 是一种”<strong>用于实现的关键字</strong>“，而不是一种”用于声明的关键字”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125; <span class="comment">// inline 与函数定义体放在一起</span></span><br></pre></td></tr></table></figure>

<p>强行使用 inline 的缺点：</p>
<ol>
<li>增大目标代码（1000+20，inline：1000*20）</li>
<li>病态换页——抖动（trash）</li>
<li>降低指令 cache 的命中率</li>
</ol>
<p>被 cc 拒绝的类型：长且复杂如 loop，swtich/指针</p>
<h2 id="程序组织"><a href="#程序组织" class="headerlink" title="程序组织"></a>程序组织</h2><p>程序结构：逻辑结构，物理结构</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256777-ff68a974-a3de-414d-8fbe-83a3aa827b6c.png#align=left&display=inline&height=518&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=499&status=done&style=none&width=499" alt=""></p>
<p>lib 文件：obj 文件的组合<br>头文件：常量的定义，变量/函数声明，类型定义，内联函数，编译预处理</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>程序级(Code,data 全生命周期)，文件级（全生命周期），函数级(stack），块级（stack）。</p>
<p>引用外部文件：extern 修饰</p>
<p>协同——》头文件</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256792-8861b183-a1eb-44f2-8960-3bd00fbe3138.png#align=left&display=inline&height=471&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=686&status=done&style=none&width=686" alt=""></p>
<p>对外不可见：static：程序级——》文件级</p>
<p>特殊：静态局部变量仍然在 stack（全生命周期）。<br>main：全生命周期，但是又在 stack（在栈底部）</p>
<p>常量：默认文件级</p>
<p><strong>总结</strong>：接口放在头文件中，不想对外使用用 static 修饰，常量通常提出一个头文件（const.h)</p>
<p>头文件：常量定义、变量/函数声明、编一预处理、类型定义，<strong>内联函数</strong></p>
<p>inline 基于源代码的复用，即将其完整写入头文件。</p>
<p>（基于目标代码的复用，只需看到接口）</p>
<p>如果 inline 被拒绝后，cc 将其变为 static（局部于文件作用域），否则同一份代码存在不同文件，造成代码冗余</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>有限的作用域更加灵活的运用</p>
<p>理念</p>
<ol>
<li>兼容：防冲突；遇冲突，可选择，易扩展</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221259730-d3a2a910-8682-46fe-8ef4-94bbe516fc31.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=475&status=done&style=none&width=475" alt=""></p>
<ol start="2">
<li>快速</li>
</ol>
<p>两种形式：</p>
<p>declaration</p>
<p>directive</p>
<p>namespace 中的变量 和全局变量命名相同时会报错</p>
<h2 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h2><h3 id="编译预处理（不懂-c-语法）"><a href="#编译预处理（不懂-c-语法）" class="headerlink" title="编译预处理（不懂 c++语法）"></a>编译预处理（不懂 c++语法）</h3><p>潜伏于环境：保持 cpp 不变，改变源程序语义</p>
<p>穿透作用域</p>
<h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ol>
<li>include： compose source text</li>
<li>define：</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256692-921e2e82-5db9-4731-83d1-771c023fecc6.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&originHeight=299&originWidth=457&status=done&style=none&width=457" alt=""></p>
<p>只是替换，无类型检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(a,b) a*b</span></span><br><span class="line"><span class="keyword">int</span> x= mul(<span class="number">1</span>+<span class="number">2</span>,<span class="number">2</span>+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x;<span class="comment">//8 not 15</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>indef</li>
<li>pragma</li>
</ol>
<p><strong>预处理指令</strong></p>
<blockquote>
<ol>
<li>#空指令，无任何效果</li>
<li>#include 包含一个源代码文件</li>
<li>#define 定义宏</li>
<li>#undef 取消已定义的宏</li>
<li>#if 如果给定条件为真，则编译下面代码</li>
<li>#ifdef 如果宏已经定义，则编译下面代码</li>
<li>#ifndef 如果宏没有定义，则编译下面代码</li>
<li>#elif 如果前面的#if 给定条件不为真，当前条件为真，则编译下面代码</li>
<li>#endif 结束一个#if……#else 条件编译块</li>
<li>#error 停止编译并显示错误信息</li>
</ol>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>c++允许数组越界</p>
<p>函数接口：void f(int a[],int n);//元素的个数需要参数显示的给出，不能通过 sizeof 获得</p>
<p>对于 char a[]=”abc”;char b[]={‘a’,’b’,’c’}; 前者可以用 cout，后者不行（无’\0’)</p>
<p>多维数组：降维处理</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597992968319-edbd867b-dc1e-4edd-8206-4932d4c1fc66.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&name=image.png&originHeight=932&originWidth=1288&size=271228&status=done&style=none&width=644" alt="image.png"></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>char s1=”abc”;等同于{‘a’,‘b’,‘c,’\0‘}</p>
<p>char s2={‘a’,‘b’,‘c}</p>
<p>烫出现原因：0xCCCC。vs 默认填充，为了容易发现错误</p>
<h3 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h3><p>和 class 区别：class 默认私有，struct 默认公开</p>
<p>alignment：以提高访问效率</p>
<p>sizeof 不一定是数据大小之和，默认对齐大小为 4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    short c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(B);<span class="comment">//12</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>共享存储空间</p>
<p>不同名称分配同一地址</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256748-b4b7c8aa-e0c2-45f2-b7bc-be549ef1297b.png#align=left&display=inline&height=253&margin=%5Bobject%20Object%5D&originHeight=253&originWidth=378&status=done&style=none&width=378" alt=""></p>
<p>公共的属性要在公共的部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> c&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    short z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(c);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597995250098-a42e9602-2791-425b-93f9-10d3b0a56038.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=1326&size=114437&status=done&style=none&width=663" alt="image.png"><br>FIGURE_TYPE 用于判断图形类别相当于标识</p>
<p>添加其他属性<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597995326962-954b78d3-ab91-465d-a6e1-eeb6c44bf2cf.png#align=left&display=inline&height=525&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1050&originWidth=1604&size=186089&status=done&style=none&width=802" alt="image.png"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>主要作用：管理地址信息。管理数据，调用代码</p>
<h4 id="定义与基本操作"><a href="#定义与基本操作" class="headerlink" title="定义与基本操作"></a>定义与基本操作</h4><p>单纯的管理地址：void*可以做公共接口，任何操作必须强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *p1=p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *q=p;</span><br><span class="line">*((<span class="keyword">int</span>*) q)</span><br></pre></td></tr></table></figure>

<p>p1 的赋值是错误的不安全。但是 q 可以，但是无法对地址对应的值进行直接操作</p>
<h6 id="pointer-literal"><a href="#pointer-literal" class="headerlink" title="pointer literal"></a>pointer literal</h6><p>nullptr：初始化不知道指针所指地址时，保证指针处于安全位置</p>
<p>c:#define NULL ((void*)0)</p>
<pre><code>可能造成问题：其他类型指针再次赋值void*，导致不同类型指针的赋值</code></pre><p>c++：#define NULL 0</p>
<pre><code>        int *p=NULL；

可能造成问题：函数重载如：func(int); func(char*);那么func(NULL)会调用第一个</code></pre><p>c++17:nullptr</p>
<p>加减数字：单位（sizeof（数据类型））</p>
<p>同类型相减：偏移量</p>
<p>输出：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256791-c3453b5b-3369-4661-83af-c364a053ca2a.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=682&status=done&style=none&width=682" alt=""></p>
<p>特例原因：cout 实现机制</p>
<p>ostream&amp;operator&lt;&lt;(osteam&amp;,char*)</p>
<h5 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h5><p>只能管理信息。除了赋值操作，必须做强制转换</p>
<p>例：将某块内存清零—&gt;把内存中的每一个 byte 设为 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span>*pointer,<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>*p=(<span class="keyword">char</span>*)pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">size</span>;k++)</span><br><span class="line">        *p++=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">100</span>]</span><br><span class="line"><span class="built_in">memset</span>(&amp;a,<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="built_in">memset</span>(&amp;B,<span class="keyword">sizeof</span>(B))</span><br></pre></td></tr></table></figure>

<h5 id="常量指针-const-TYPE-NAME"><a href="#常量指针-const-TYPE-NAME" class="headerlink" title="常量指针 const TYPE *NAME"></a>常量指针 const TYPE *NAME</h5><p>常量指针不可赋值 只读不写</p>
<p>const 变量只能用常量指针获取地址（不能间接改变常量）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256690-ebf8998d-a63f-4e28-a88a-3c3ec5557147.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=429&status=done&style=none&width=429" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*cp=<span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">*p=<span class="number">2</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">2</span>;</span><br><span class="line">cp=&amp;y;<span class="comment">//正确</span></span><br><span class="line">q=&amp;x;<span class="comment">//错误，不能间接地改变常量 q=const_cast&lt;int*&gt;(&amp;x)</span></span><br></pre></td></tr></table></figure>

<p>改变读写权限/保护变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>*p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//不可用</span></span><br></pre></td></tr></table></figure>

<p>const_cast&lt;int*&gt;取消常量属性</p>
<h5 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h5><p>只能在定义时初始化。<br>int*const p=&x;</p>
<p>不可移动的指针，但是可以管理内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p=&amp;x;</span><br><span class="line"></span><br><span class="line">p=&amp;y;<span class="comment">//错误，p不能移动；</span></span><br><span class="line">*p=<span class="number">1</span>;<span class="comment">//正确，可以改变内存的值,x会变</span></span><br></pre></td></tr></table></figure>

<p>const int*const p//初始化值和所指内容都不能改变</p>
<h5 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h5><p>&lt;&gt;()()</p>
<p>类型 （*函数名） （类型，类型，….)</p>
<p>函数指针和表驱动</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597998896529-520f1347-ac08-41a4-b418-62c158211726.png#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1278&originWidth=1698&size=269513&status=done&style=none&width=615" alt="image.png"></p>
<h5 id="指针与数组："><a href="#指针与数组：" class="headerlink" title="指针与数组："></a>指针与数组：</h5><p>数组名实际是地址（int*const)常量地址长度</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597999254696-4d455e67-ceda-4340-91e9-ddaab1a3dda4.png#align=left&display=inline&height=522&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1044&originWidth=1742&size=315545&status=done&style=none&width=871" alt="image.png"><br>指针数组：</p>
<p>char*s1[]={“c++”,”java”,”python”}（存的是引用）</p>
<p>char *s2[][8]={“c++”,”java”,”python”}(存的是字符）</p>
<p>main 函数：</p>
<p>int main(int agrc, char*<em>argv[],char</em> env[])</p>
<p>argc：参数个数</p>
<p>argv：命令行参数</p>
<p>env：环境参数</p>
<p>可变参数：</p>
<p>int printf(const char*,…)</p>
<h5 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h5><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597999940520-31b5e962-a193-4b67-af69-5cced1130d7c.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&name=image.png&originHeight=814&originWidth=1520&size=136785&status=done&style=none&width=760" alt="image.png"></p>
<h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><p>stack(生存规律可知)</p>
<p>heap 生命周期由程序决定</p>
<p>非编译时刻确定，存在 heap</p>
<h4 id="申请与归还"><a href="#申请与归还" class="headerlink" title="申请与归还"></a>申请与归还</h4><p>new&lt;类型&gt;</p>
<p>int  *p=new int;</p>
<p>int &amp;a=*p;(引用)</p>
<p>delete p;(归还)</p>
<p>或者是，</p>
<p>int<em>p=(int</em>) malloc(sizeof(int))</p>
<p>free(p);</p>
<p>申请一组：</p>
<p>new &lt;类型&gt;[整型数组]</p>
<p>int *p=new int[16]</p>
<p>int<em>p=(int</em>) malloc(sizeof(int)*16)</p>
<p>多维数组的申请</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> i5arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5arr *p=<span class="keyword">new</span> i5arr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*q)[<span class="number">5</span>]=(<span class="keyword">int</span>(*)[<span class="number">5</span>])p;</span><br></pre></td></tr></table></figure>

<p>由于申请内存可能申请不到，因此需要判断是否有效，做异常处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p!=null)</span><br><span class="line">    <span class="comment">//.....</span></span><br></pre></td></tr></table></figure>

<p>delete /delete[]：面向对象编程时，前者只会调用数组第一个的析构函数，后者会逐个调用每个对象的析构函数</p>
<p>free：只归还空间不调用析构函数</p>
<p>内存分配时，系统会自动创建一个 cookie，其包含了分配大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    *(p++)=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line"><span class="comment">//这样会导致系统free128个单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此,不能移动申请指针</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> *q=p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    *(q++)=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br></pre></td></tr></table></figure>

<h4 id="new-和-malloc-差别"><a href="#new-和-malloc-差别" class="headerlink" title="new 和 malloc 差别"></a>new 和 malloc 差别</h4><p>语法上 malloc 需要强制类型转换</p>
<p>语义上 面向对象编程时，new 会自动调用构造函数</p>
<h4 id="应用——链表"><a href="#应用——链表" class="headerlink" title="应用——链表"></a>应用——链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> content;</span><br><span class="line">    NODE*next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE*head=<span class="literal">NULL</span>:</span><br></pre></td></tr></table></figure>

<p>Insert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NODE*p=<span class="keyword">new</span> NODE;</span><br><span class="line">p-&gt;content=_value;</span><br><span class="line">p-&gt;next=null;</span><br><span class="line"><span class="comment">//头部插入</span></span><br><span class="line">p-&gt;next=head;</span><br><span class="line">head=p;</span><br><span class="line"><span class="comment">//尾部插入</span></span><br><span class="line">NODE*q=head;</span><br><span class="line"><span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">q-&gt;next=p;</span><br><span class="line"><span class="comment">//中间结点后插入</span></span><br><span class="line">NODE*q=head;</span><br><span class="line"><span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>&amp;&amp;q-&gt;content!=a)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    q-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>;</span><br><span class="line"><span class="comment">//中间结点前插入（双指针）</span></span><br><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;</span><br><span class="line"><span class="keyword">while</span> (q2 !=<span class="literal">NULL</span>  &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q2  != <span class="literal">NULL</span>) 	<span class="comment">//存在a</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>  (<span class="literal">NULL</span> == q1) 	<span class="comment">// a是第一个结点</span></span><br><span class="line">       &#123;   p-&gt;next = q2; head = p;   &#125;</span><br><span class="line">    <span class="keyword">else</span>  	<span class="comment">// a不是第一个结点</span></span><br><span class="line">      &#123;    p-&gt;next = q2;    q1-&gt;next = p;  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span>    <span class="comment">//不存在ai</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found!"</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221256771-75c3ba7c-66ce-4c0e-9e2c-47f1626ee278.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=782&status=done&style=none&width=782" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>为一块已有的内存空间取别名</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597221259627-7be42acf-3d37-47c2-bb0f-52ea9cac25e8.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=418&status=done&style=none&width=418" alt=""><br>不能返回局部变量</p>
<p>#</p>
]]></content>
      <categories>
        <category>互联网计算复习</category>
      </categories>
  </entry>
  <entry>
    <title>PART2 OOP</title>
    <url>/2020/08/29/wf7rf9/</url>
    <content><![CDATA[<h2 id="oo-十问"><a href="#oo-十问" class="headerlink" title="oo 十问"></a>oo 十问</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522561-b8a98a05-6e3c-471f-a45a-8e7f1468205c.png#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=775&status=done&style=none&width=775" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522541-f8f1bb96-4ea4-4d5d-9942-6eff8cae02d7.png#align=left&display=inline&height=420&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=679&status=done&style=none&width=679" alt=""></p>
<p>结构化——》命令的集合，可化为线性</p>
<p>oo：向对象发送消息</p>
<p>分类：Objected-Oriented</p>
<p>Object-Based (without Inheritance)</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>成员变量，成员函数<br>头文件和源文件<br>头文件：声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tdate</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">isLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> year,month,day;</span><br><span class="line">&#125;;<span class="comment">//头文件date.h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tdate::setDate</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Tdate加在函数名之前返回类型后面，说明是头文件类的方法</span></span><br><span class="line">    year=y;</span><br><span class="line">    month=m;</span><br><span class="line">    data=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tdate::isLeapYear</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="comment">//源文件date.cpp</span></span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//直接创建对象，并非引用。全局对象，创建在全局静态存储区域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     g.SetDate(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      TDate t;<span class="comment">//存储在栈区</span></span><br><span class="line">      t.SetDate(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">      TDate  *p = <span class="keyword">new</span> TDate;<span class="comment">//引用，heap</span></span><br><span class="line">      p-&gt;SetDate(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接在头文件实现类，那么编译器会将成员函数作为 inline 函数。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>对象的初始化，内存的分配。</p>
<p>与类同名，无返回类型；自动调用，不可以直接调用；可重载</p>
<p>默认构造函数，无参数。当类中未提供构造函数时，编译系统提供</p>
<p>当一个对象未完成初始化时，其内存是不确定，此时并不算完整的对象。因此，默认构造函数，主要任务是建立标识符，对其内存分配，而非成员变量的赋值。</p>
<p>： 单例，只能通过类内部进行创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">作用：保证一个<span class="class"><span class="keyword">class</span>只有一个实体（<span class="title">instance</span>），并为它提供一个全局唯一的访问点</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~singleton()&#123;<span class="comment">//析构时使用&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(_instance == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_instance = <span class="keyword">new</span> singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> _instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> singleton *_instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//最好将所有此类的实例化的进口全部堵死</span></span><br><span class="line">	singleton()</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	singleton(<span class="keyword">const</span> singleton&amp;)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton &amp;)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524736-30434b7f-0a56-48c9-b22c-a17e4cfae07b.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&originHeight=317&originWidth=627&status=done&style=none&width=627" alt=""></p>
<h3 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h3><p>构造函数的补充，减轻编译器负担</p>
<p>先于构造函数，按类数据成员申明次序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span>&amp;z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A():y(<span class="number">1</span>),z(x),x(<span class="number">0</span>)&#123;x=<span class="number">100</span>&#125;;<span class="comment">//顺序是先初始化x,y,z，x=100是赋值，不是初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990522560-1d7137f7-5e97-4bba-9e36-22ba5ded106b.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&originHeight=156&originWidth=412&status=done&style=none&width=412" alt=""></p>
<p>初始化大小不是 x：size 未初始化（先初始化的 p）</p>
<p>成员初始化表作用：</p>
<p>与 Java 不同的是，成员变量除了常量类型外，不允许在类内部初始化（C98）</p>
<p>减轻编译器负担：如果用构造函数赋值，对象已经初始化一次，及赋值了两次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A()&#123;m=<span class="number">0</span>;&#125;</span><br><span class="line">    	A(<span class="keyword">int</span> m1)&#123;m=m1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    A a;<span class="comment">//成员对象</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	B()&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    	B(<span class="keyword">int</span> x1)&#123;x=x1;&#125;</span><br><span class="line">    	B(<span class="keyword">int</span> x1,<span class="keyword">int</span> m1):a(m1)&#123;x=x1;&#125;<span class="comment">//指定成员对象的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;        <span class="comment">//调用B::B()和A::A()</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">//调用B::B(int)和A::A()</span></span><br><span class="line">    <span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//调用B::B(int,int)和A::A(int)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524066-4f5bd7e8-0f9b-4e51-891d-a9b844c2c311.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=674&status=done&style=none&width=674" alt=""></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象消亡，系统自动调用，heap 上的对象需要手动调用</p>
<p>释放对象持有的非内存资源</p>
<p>可声明为 private：无法在 stack 上分配对象，只能在 heap 上，强制自主控制对象存储分配,也不能直接 delete，需用手动调用对象的消除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A():</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	～A();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;<span class="comment">//报错</span></span><br><span class="line">    A *p=<span class="keyword">new</span> A;<span class="comment">//只能在堆上分配对象（栈资源有限）</span></span><br><span class="line">    p-&gt;destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数，类中获取的额外资源（文件资源，网络资源等）释放</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>创建对象时，用一同类的对象对其初始化</p>
<p>自动调用</p>
<blockquote>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
</blockquote>
<p>public:A(const A&amp; a);(引用&amp;，否则变为递归)</p>
<p>默认拷贝构造函数：Ø 逐个成员初始化(member-wise initialization) Ø 对于对象成员，该定义是递归的</p>
<p>浅拷贝问题：悬挂指针（解决：重载拷贝构造函数和操作符=）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524066-4f5bd7e8-0f9b-4e51-891d-a9b844c2c311.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=674&status=done&style=none&width=674" alt=""></p>
<p>通常在深拷贝时，采用自定义拷贝构造函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525301-71ad3959-7990-4188-b92a-51afc3afc4e7.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=309&originWidth=339&status=done&style=none&width=339" alt=""></p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> S=generate();</span><br></pre></td></tr></table></figure>

<p>可声明成 private:编译器不能调用拷贝构造函数，防止对象按值传递（需按引用传递）</p>
<h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525352-8b4e118c-d920-4036-844a-17cc6e025798.png#align=left&display=inline&height=452&margin=%5Bobject%20Object%5D&originHeight=452&originWidth=730&status=done&style=none&width=730" alt=""></p>
<p>在 heap 中创建对象</p>
<p>引入 new,delete:正确引用 constructor/destructor</p>
<p>malloc 不调用构造函数</p>
<p>free 不调用析构函数</p>
<p>new 可重载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A();</span><br><span class="line">    	A();</span><br><span class="line">&#125;</span><br><span class="line">A *p,*q;</span><br><span class="line">p = <span class="keyword">new</span> A;</span><br><span class="line"> <span class="comment">//在程序的heap中申请一块大小为sizeof(A)的内存</span></span><br><span class="line"><span class="comment">//调用A的默认构造函数对该空间上的对象初始化</span></span><br><span class="line"><span class="comment">//返回创建的对象的地址并赋值给p malloc不会进行后两步</span></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用A的另一个构造函数 A::A(int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>  p;</span><br><span class="line"><span class="comment">//调用p所指向的对象的析构函数</span></span><br><span class="line"><span class="comment">//释放对象空间</span></span><br><span class="line"><span class="keyword">delete</span> q;</span><br></pre></td></tr></table></figure>

<p>对象创建：</p>
<p>type ptrName= new type;</p>
<p>type ptrName= new type（params);</p>
<p>对象删除：</p>
<p>delete 后设置指针为 NULL</p>
<p>delete intPtr;</p>
<p>inPtr=NULL;//否则该指针为悬挂指针，今后可能用</p>
<h4 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p=<span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"><span class="comment">//不能显示初始化，相应的类必须有默认构造函数，delete 中[]不能省</span></span><br></pre></td></tr></table></figure>

<h4 id="动态二维数组"><a href="#动态二维数组" class="headerlink" title="动态二维数组"></a>动态二维数组</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525296-fa4e4608-d1a8-4f84-b8d4-9f42b9dd1daf.png#align=left&display=inline&height=468&margin=%5Bobject%20Object%5D&originHeight=468&originWidth=853&status=done&style=none&width=853" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990528333-147a995c-747b-4261-bc48-975ae71b9975.png#align=left&display=inline&height=413&margin=%5Bobject%20Object%5D&originHeight=413&originWidth=567&status=done&style=none&width=567" alt=""></p>
<h3 id="const-成员"><a href="#const-成员" class="headerlink" title="const 成员"></a>const 成员</h3><p>初始化放在成员初始化表中，原因：常量只能在初始化时确定值，不能赋值</p>
<p>类中 const 成员，仅在类生存的生命周期内存在，特殊情况：static const 编译期内常量</p>
<p>const 成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span>  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	     A(<span class="keyword">int</span> c): x(c) &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const 成员函数，加上关键字 const（方法声明之后）</p>
<p>常对象只能调用常成员函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="built_in">cout</span> &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">a.f();<span class="comment">//error,不可更改常对象内容</span></span><br><span class="line">a.show();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 f()定义为 const，编译器会报错原因如下<br>类中函数默认参数有<em>const this；<br>void f(A</em> const this)<br>当 const 修饰时，void show(const A* const this);this 指向对象内容不可更改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> &amp; indirect_int;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     A():indirect_int(*<span class="keyword">new</span> <span class="keyword">int</span>)&#123; ... &#125;</span><br><span class="line">    ~A() &#123; <span class="keyword">delete</span> &amp;indirect_int; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; indirect_int++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可更改indirect_int</span></span><br></pre></td></tr></table></figure>

<p>可看出 const 是防止直接改变值。</p>
<p>mutable：允许直接改变值。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>同一个类不同对象共享变量：</p>
<ol>
<li>如果共享变量定义为全局变量，则缺乏数据保护</li>
<li>名污染。不同类访问共同的变量</li>
</ol>
<p>静态成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>   x,y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> shared;</span><br><span class="line">        .....</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">int</span> A::shared=<span class="number">0</span>;<span class="comment">//定义必须放在类的外部，放在实现文件，不放在头文件，且只能定义一次</span></span><br><span class="line">A a, b;</span><br></pre></td></tr></table></figure>

<p>静态成员函数：只能存取 静态成员函数，调用静态成员函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">	&#123;</span>    <span class="keyword">static</span> <span class="keyword">int</span> shared;</span><br><span class="line">	     <span class="keyword">int</span> x;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">	     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; …shared…&#125;</span><br><span class="line">	     <span class="function"><span class="keyword">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; …x…shared…&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524697-274823ec-ef23-4036-8239-7219cf86ce0c.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&originHeight=353&originWidth=436&status=done&style=none&width=436" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>	&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> obj_count;</span><br><span class="line">	        …</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	      A()  &#123;   obj_count++; &#125;</span><br><span class="line">	      ~A()  &#123;   obj_count--; &#125;</span><br><span class="line">	      static int get_num_of_obj() ；</span><br><span class="line">	         …</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>  A::obj_count=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>  <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br><span class="line"><span class="comment">//类对象计数</span></span><br></pre></td></tr></table></figure>

<p>example：</p>
<p>单件模式 singleton</p>
<p>构造函数为私有，用静态函数计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">protected</span>:<span class="comment">//外界不能创建</span></span><br><span class="line">		 singleton()&#123;&#125;</span><br><span class="line">		 singleton(<span class="keyword">const</span> singleton &amp;);</span><br><span class="line">	<span class="keyword">public</span>:<span class="comment">//static来创建</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;   <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>?</span><br><span class="line">				m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">static</span> singleton * m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">singleton * singleton ::m_instance= <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类外部不能访问该类的 private 成员。若通过该类的 public 方法会降低 private 成员的访问效率</p>
<p>友元可以访问该类的私有变量或者函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524440-4c2829cb-3775-449a-8a0e-068b7ac8bf29.png#align=left&display=inline&height=279&margin=%5Bobject%20Object%5D&originHeight=279&originWidth=626&status=done&style=none&width=626" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">C::f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元不具有传递性</p>
<p>使用友元的原则</p>
<ul>
<li>避免将 data member 放在公开接口中</li>
<li>努力让接口完满且最小化</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于目标代码复用</p>
<h3 id="单继承（考试重点）"><a href="#单继承（考试重点）" class="headerlink" title="单继承（考试重点）"></a>单继承（考试重点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span>       <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="keyword">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">set_ID</span><span class="params">(<span class="keyword">int</span> x)</span>  </span>&#123; id = x; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">SetNickName</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname,s);&#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         </span>&#123; <span class="built_in">cout</span> &lt;&lt; nickname &lt;&lt; “ : “ &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"> 		 <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; nickname &lt;&lt; “ : “ &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Undergraduated_Student</span> :</span> <span class="keyword">public</span> Student<span class="comment">//建议public继承</span></span><br><span class="line">&#123;       <span class="keyword">int</span> dept_no;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">set_ID</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;...&#125;<span class="comment">//id不可访问</span></span><br><span class="line">		 <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;dept_no&lt;&lt;<span class="string">":"</span>&lt;&lt;nickname&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         &#125;<span class="comment">//overwritten，对基类所有同名函数隐藏</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">   		Student::nickname;<span class="comment">//要声明作用域，否则是重新声明</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">setNickName</span><span class="params">()</span>:</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student u;</span><br><span class="line">u.showInfo(<span class="number">10</span>);<span class="comment">//error.不可访问。在Undergraduated_Student名空间进行匹配，匹配上showInfo时进行参数匹配。参数匹配不上，不再会去其他名空间匹配。可以using Student::showInfo</span></span><br></pre></td></tr></table></figure>

<p>在没有继承的情况下，protected 和 private 相同。有继承时，派生类可以访问基类的 protected 成员</p>
<p>派生类不能访问基类对象的 protected 成员(传入已创建好的基类对象）</p>
<p>派生类继承基类中的数据，但不可访问</p>
<p>如果不是公有继承则基类中的所有 public 成员将会变为 private</p>
<p>构造函数和析构函数，赋值操作符重载函数不可继承。</p>
<p>c++与 Java 不同的是，派生类中的函数是重写而不是覆盖。如果需要覆盖，需要指明该函数是 virtual。只要派生类中有同名函数，会对基类其他所有同名函数（参数可能不同）进行隐藏。</p>
<p>。即虚函数。虚函数代表的是多态，而重写是静态绑定</p>
<p>继承方式：private，基类中的成员只和基类访问说明符有关。派生类的用户（派生类的派生类）则与继承方式有关</p>
<h3 id="友元和-protected"><a href="#友元和-protected" class="headerlink" title="友元和 protected"></a>友元和 protected</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Base</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">protected</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> prot_mem;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; ;</span></span></span><br><span class="line"><span class="function"><span class="params">class Sneaky : <span class="keyword">public</span> Base &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">friend</span> <span class="keyword">void</span> clobber&#123;Sneaky&amp;)</span> </span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> clobber&#123;Base&amp;);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//正确：clobber 能访问Sneaky对象的private和protected成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误： clobber 不能访问Base的protected 成员</span></span><br></pre></td></tr></table></figure>

<p>原因是，派生类的友元只能访问派生类的基类保护成员，不能直接访问基类友元</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524402-eeeb8d10-53c8-4536-bfe2-526110668ec4.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=402&status=done&style=none&width=402" alt=""></p>
<p>成员对象初始化与声明顺序有关</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1598017699970-6a043c4a-e925-4498-8096-dffcc238a728.png#align=left&display=inline&height=504&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1008&originWidth=1538&size=299830&status=done&style=none&width=769" alt="image.png"><br>B 的拷贝构造函数会默认初始化 A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A; <span class="comment">//继承A所有的构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="类型相容"><a href="#类型相容" class="headerlink" title="类型相容"></a>类型相容</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524694-4eb4860d-8c5b-453c-9f17-d9273e61e519.png#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&originHeight=176&originWidth=580&status=done&style=none&width=580" alt=""></p>
<p>派生类对象赋值给基类：对象切片 ↑（a 对应存储空间比 b 小，b 中自有属性会丢失）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524487-b4dc6879-2c99-404c-b71d-603f33184fb9.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=566&status=done&style=none&width=566" alt=""></p>
<p>传参数尽量传引用否则会产生对象切片（信息会丢失）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525380-c184975f-696a-4ad2-99e1-ddbb3c0e87cf.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=760&status=done&style=none&width=760" alt=""></p>
<p>func1，func2 A::f()只看形参的类型（静态绑定）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524693-3c7e9160-7cee-45d6-a41b-47b40b3fe191.png#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&originHeight=437&originWidth=439&status=done&style=none&width=439" alt=""></p>
<p>C++默认前期绑定，java 默认动态绑定</p>
<p>动态绑定：根据实际引用和指向对象的类型。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法重定义（override）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525389-271dc85b-f530-4d29-9fbe-502c076108a2.png#align=left&display=inline&height=419&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=711&status=done&style=none&width=711" alt=""></p>
<h4 id="后期绑定的实现"><a href="#后期绑定的实现" class="headerlink" title="后期绑定的实现"></a>后期绑定的实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>     <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    h();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;      <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       f();</span><br><span class="line">      h();</span><br><span class="line">&#125;;</span><br><span class="line">A a; B b;</span><br><span class="line">A *p;</span><br><span class="line">p=&amp;a;或者p=&amp;b;</span><br><span class="line">p-&gt;f();<span class="comment">//f的实现与对象内存绑定在一起</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990528391-f92e3af0-1c9b-4fa6-9d3e-e58c899d3c06.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=530&status=done&style=none&width=530" alt=""></p>
<p>(*_((char _)p-4))(p)//函数调用即 p-&gt;f()</p>
<p>虚函数表(vtable)索引表</p>
<p>效率低：</p>
<p>空间：多 1byte，以及虚函数表</p>
<p>时间：指针的寻址。多一次解引用</p>
<p>非虚函数调用虚函数&amp;虚函数调用非虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">public</span>:</span><br><span class="line">	    A() &#123; f();&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; f(); g(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b; <span class="comment">//先调用A的构造函数A::A(),A::f(),B::B() 建议不要在构造函数中调用虚函数</span></span><br><span class="line">A *p=&amp;b;</span><br><span class="line">p-&gt;f(); <span class="comment">// B::f()</span></span><br><span class="line">p-&gt;g(); <span class="comment">//A::g() g是静态绑定的，与p类型有关</span></span><br><span class="line">p-&gt;h();	<span class="comment">//A::h, B::f, A::g    h也称为非虚接口即调用虚函数也调用非虚函数，可以替换部分内容，对应着模板模式。全局函数可以做成非虚接口来实现多态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span> </span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span> </span>&#123; g(); &#125;<span class="comment">//f(B* const this)，this-&gt;g();</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;f(); <span class="comment">//都调用b的版本，虚函数调用非虚函数，对象是派生类的</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525365-a070081c-5a5a-4dad-baf9-04ca59dfd6a5.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=709&status=done&style=none&width=709" alt=""></p>
<p>int f2()override//错误，编译器不允许编译器的重定义</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>相当于 Java 里的接口</p>
<p>声明时，在函数原型后面加上=0；</p>
<p>往往只声明，不实现</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>至少包含一个纯虚函数</p>
<p>不能创建对象,为派生类提供框架，派生类提供抽象基类的所有成员函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class">&#123;</span>      …</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990524775-e0fda813-8f9d-4043-b50f-64b0eb49b953.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=621&status=done&style=none&width=621" alt=""></p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525364-12d2c664-1371-4d03-8c10-8cb6eabe29a8.png#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=663&status=done&style=none&width=663" alt=""></p>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><h4 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h4><p>只继承实现，不继承接口。（派生类不转化为基类</p>
<p>has-a 关系</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525442-2f6ae85b-5523-4b64-b62a-b7c53a9ff50e.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=814&status=done&style=none&width=814" alt=""></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>定义：</p>
<p><em>class</em> &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名 1&gt;，</p>
<p>[&lt;继承方式&gt;] &lt;基类名 2&gt;，…</p>
<p><em>{</em> 〈成员表〉<em>}</em></p>
<p>继承方式</p>
<p><em>public_、_private</em> 、<em>protected</em></p>
<p>继承方式及访问控制的规定同单继承</p>
<p>派生类拥有所有基类的所有成员</p>
<p>初始化顺序/基类的声明次序：</p>
<p>对基类构造函数/析构函数的调用次序</p>
<p>对基类数据成员的存储安排</p>
<p>名冲突：&lt;基类名&gt;::&lt;基类成员名&gt;</p>
<p>虚基类</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/392607/1597990525369-da07800c-5372-4d55-9fda-7bed69dfba14.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&originHeight=303&originWidth=584&status=done&style=none&width=584" alt=""></p>
<p>#</p>
]]></content>
  </entry>
</search>
